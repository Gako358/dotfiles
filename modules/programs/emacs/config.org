#+STARTUP: overview
#+TITLE: MerrinX Config
#+CREATOR: Merrinx
#+LANGUAGE: en

* Installation
Git clone https://github.com/gako358/dotfiles.git.
The configuration is setup using NixOS, check README.


** Appearance
Using the dashboard package with the kaolin-theme to enhance the startup experience and overall look of Emacs.

*** Dashboard
The dashboard package is configured to display a welcoming startup screen with a custom banner, recent files, bookmarks, projects, and agenda items.

#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (setq dashboard-startup-banner 'logo
  	  dashboard-banner-logo-title "Welcome back Supreme (Scrum) leader..."
  	  dashboard-set-file-icons t
  	  dashboard-center-content t
  	  dashboard-items '((recents  . 5)
  			    (bookmarks . 5)
  			    (projects . 5)
  			    (agenda . 5))
  	  initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
    :init
    :hook (after-init . dashboard-setup-startup-hook))
#+end_src

*** Fonts
Custom fonts are set using "Iosevka Nerd Font" for both the main text and the mode-line, ensuring a consistent and visually appealing interface across all frames.

#+begin_src emacs-lisp
  (add-hook 'after-make-frame-functions
	    (lambda (f)
	      (with-selected-frame f
		(set-frame-font "Iosevka Nerd Font 11" nil t)
		(set-face-attribute 'mode-line nil :font "Iosevka Nerd Font 12" :height 100))))

  (add-to-list 'default-frame-alist '(height . 64))
  (add-to-list 'default-frame-alist '(width . 370))
#+end_src

*** Icons
All-the-icons: Provides a rich set of icons for various file types and modes.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+end_src

All-the-icons-ivy-rich: Enhances Ivy's minibuffer completion with icons, activated on startup.

#+begin_src emacs-lisp
  (use-package all-the-icons-ivy-rich
    :ensure t
    :init (all-the-icons-ivy-rich-mode 1))
#+end_src

Nerd-icons: Sets "Iosevka Nerd Font" as the icon font family.
Nerd-icons-completion: Integrates with Marginalia for enhanced completion visuals.
Nerd-icons-corfu: Adds pretty icons to Corfu completion menus.

#+begin_src emacs-lisp
  (use-package nerd-icons
    :ensure t
    :config
    (setq nerd-icons-font-family "Iosevka Nerd Font"))

  ;; Pretty icons for completion
  (use-package nerd-icons-completion
    :ensure t
    :after marginalia
    :config
    (nerd-icons-completion-marginalia-setup)
    (nerd-icons-completion-mode 1))

  (use-package nerd-icons-corfu
    :ensure t
    :after corfu
    :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

#+end_src

*** Modeline
This enables spaceline, it looks better and works very well with my theme of choice.

#+begin_src emacs-lisp
  (use-package spaceline
    :ensure t
    :init
    (setq spaceline-buffer-encoding-abbrev-p nil
  	  spaceline-line-column-p nil
  	  spaceline-line-p nil
  	  powerline-default-separator 'arrow
  	  powerline-gui-use-vcs-glyph t
  	  powerline-height 28
  	  spaceline-highlight-face-func 'spaceline-highlight-face-modified
  	  spaceline-workspace-numbers-unicode t
  	  spaceline-window-numbers-unicode t
  	  spaceline-separator-dir-left '(left . right)
  	  spaceline-separator-dir-right '(right . left)
  	  spaceline-flycheck-bullet "❀ %s")
    :config
    (require 'spaceline-config)
    (spaceline-spacemacs-theme)

    (spaceline-define-segment nasy:version-control
      "Version control information."
      (when vc-mode
        (let ((branch (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-")))
          (powerline-raw
           (s-trim (concat "  "
                           branch
                           (when (buffer-file-name)
                             (pcase (vc-state (buffer-file-name))
                               (`up-to-date " ✓")
                               (`edited " ❓")
                               (`added " ➕")
                               (`unregistered " ■")
                               (`removed " ✘")
                               (`needs-merge " ↓")
                               (`needs-update " ↑")
                               (`ignored " ✦")
                               (_ " ⁇")))))))))

    (spaceline-define-segment nasy-time
      "Time"
      (format-time-string "%b %d, %Y - %H:%M ")
      :tight-right t)

    (spaceline-define-segment flycheck-status
      "An `all-the-icons' representation of `flycheck-status'"
      (let* ((text
              (pcase flycheck-last-status-change
                (`finished (if flycheck-current-errors
                               (let ((count (let-alist (flycheck-count-errors flycheck-current-errors)
                                              (+ (or .warning 0) (or .error 0)))))
                                 (format "✖ %s Issue%s" count (if (eq 1 count) "" "s")))
                             "✔ No Issues"))
                (`running     "⟲ Running")
                (`no-checker  "⚠")
                (`not-checked "✣ Disabled")
                (`errored     "⚠ Error")
                (`interrupted "⛔ Interrupted")
                (`suspicious  "")))
             (f (cond
                 ((string-match "⚠" text) `(:height 0.9 :foreground ,(face-attribute 'spaceline-flycheck-warning :foreground)
                                                    :background "#1d5464"))
                 ((string-match "✖ [0-9]" text) `(:height 0.9 :foreground ,(face-attribute 'spaceline-flycheck-error :foreground)
                                                          :background "#333333"))
                 ((string-match "✣ Disabled" text) `(:height 0.9))
                 (t '(:height 0.9 :inherit)))))
        (propertize (format " %s " text)
                    'face f
                    'help-echo "Show Flycheck Errors"
                    'mouse-face '(:box 1)
                    'local-map (make-mode-line-mouse-map 'mouse-1 (lambda () (interactive) (flycheck-list-errors)))))
      :when active))
#+end_src

*** Themes
The bivrost-theme.

#+begin_src emacs-lisp
  (use-package bivrost-theme
    :ensure t
    :config
    (load-theme 'bivrost t))
#+end_src

** Completion
Using Corfu, vertico and cape for code completion.

#+begin_src emacs-lisp
  ;; Enable indentation and completion with the TAB key.
  (setq tab-always-indent 'complete)

  ;; Cycle with the TAB key if there are only few candidates.
  (setq completion-cycle-threshold 3)
#+end_src

*** Cape
Completion At Point Extensions:
- Cape: Provides extensions for completion-at-point-functions to enhance the completion experience for files and Emacs Lisp blocks.

#+begin_src emacs-lisp
  ;; Completion At Point Extensions.
  (use-package cape
    :ensure t
    :init
    (add-to-list 'completion-at-point-functions
  	       (cape-capf-accept-all #'cape-dabbrev)) ;; This to get all from buffer
    (add-to-list 'completion-at-point-functions
  		 (cape-capf-accept-all #'cape-keyword)) ;; To get all from language
    (add-to-list 'completion-at-point-functions #'cape-history)
    (add-to-list 'completion-at-point-functions #'cape-abbrev)
    (add-to-list 'completion-at-point-functions #'cape-file)
    (add-to-list 'completion-at-point-functions #'cape-elisp-block)

    :config
    ;; Make dabbrev check other buffers for more comprehensive completions
    ;; (setq cape-dabbrev-check-other-buffers t) Not sure this will be a good idea

    ;; Set up insert mode specific bindings
    (with-eval-after-load 'evil
      (define-key evil-insert-state-map (kbd "C-c p o") 'completion-at-point)
      (define-key evil-insert-state-map (kbd "C-c p d") 'cape-dabbrev)
      (define-key evil-insert-state-map (kbd "C-c p f") 'cape-file)
      (define-key evil-insert-state-map (kbd "C-c p h") 'cape-history)
      (define-key evil-insert-state-map (kbd "C-c p k") 'cape-keyword)
      (define-key evil-insert-state-map (kbd "C-c p s") 'cape-elisp-symbol)
      (define-key evil-insert-state-map (kbd "C-c p e") 'cape-elisp-block)
      (define-key evil-insert-state-map (kbd "C-c p a") 'cape-abbrev)
      (define-key evil-insert-state-map (kbd "C-c p l") 'cape-line)
      (define-key evil-insert-state-map (kbd "C-c p w") 'cape-dict)
      (define-key evil-insert-state-map (kbd "C-c p :") 'cape-emoji)
      (define-key evil-insert-state-map (kbd "C-c p &") 'cape-sgml)
      (define-key evil-insert-state-map (kbd "C-c p r") 'cape-rfc1345)))
#+end_src

*** Corfu
Completion Overlay Region Function:
- Corfu: Provides a completion overlay for better in-line completion, with custom keybindings for navigation and configuration for an improved user experience.

#+begin_src emacs-lisp
  ;; Completion Overlay Region Function.
  (use-package corfu
    :init
    (global-corfu-mode 1)
    (setq global-corfu-minibuffer
  	    (lambda ()
  	      (not (or (bound-and-true-p mct--active)
  		       (bound-and-true-p vertico--input)
  		       (eq (current-local-map) read-passwd-map)))))
    :bind (:map corfu-map
  				  ("C-n" . corfu-next)
  				  ("C-p" . corfu-previous)
  				  ("C-h" . corfu-info-documentation)
  				  ("C-S-t" . my/corfu-quit-or-abort)
  				  )

    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-preview-current nil)
    (corfu-quit-at-boundary t)
    (corfu-quit-no-match t)

    :config
    ;; Add Evil-specific binding for C-y in Corfu
    (with-eval-after-load 'evil
      (define-key evil-insert-state-map (kbd "C-y")
                  (lambda ()
                    (interactive)
                    (if (and (boundp 'corfu-mode) corfu-mode)
                        (corfu-insert)
                      (evil-paste-before 1)))))

    (defun my/corfu-quit-or-abort ()
      "Abort Corfu if active, otherwise fall back to default behavior."
      (interactive)
      (if corfu--frame
          (corfu-quit)
        (keyboard-escape-quit)))
    )
#+end_src

*** Copilot
Github copilot extension for emacs
Complete `use-package' configuration for copilot, incorporating:

#+begin_src emacs-lisp
  (use-package copilot
    :bind (:map copilot-completion-map
  	      ("<tab>" . 'copilot-accept-completion)
  	      ("TAB" . 'copilot-accept-completion)
  	      ("C-TAB" . 'copilot-accept-completion-by-word)
  	      ("C-<tab>" . 'copilot-accept-completion-by-word))
    :config
    ;; Helper to turn copilot-mode off in a buffer (useful for hooks)
    (defun rk/no-copilot-mode ()
      "Helper to disable `copilot-mode' in the current buffer."
      (when (bound-and-true-p copilot-mode)
  	(copilot-mode -1)))

    ;; Modes where Copilot should be disabled
    (defvar rk/no-copilot-modes
      '(shell-mode
        inferior-python-mode
        eshell-mode
        term-mode
        vterm-mode
        comint-mode
        compilation-mode
        debugger-mode
        dired-mode))

    (add-to-list 'copilot-indentation-alist '(prog-mode 2))
    (add-to-list 'copilot-indentation-alist '(org-mode 2))
    (add-to-list 'copilot-indentation-alist '(text-mode 2))
    (add-to-list 'copilot-indentation-alist '(closure-mode 2))
    (add-to-list 'copilot-indentation-alist '(emacs-lisp-mode 2))
    )
#+end_src

*** Embark
Context Menu for Actions:
- Embark: Offers a context menu for performing actions on selected items directly from the completion interface.

#+begin_src emacs-lisp
  (use-package embark
    ;; Embark is an Emacs package that acts like a context menu, allowing
    ;; users to perform context-sensitive actions on selected items
    ;; directly from the completion interface.
    :ensure t
    :defer t
    :commands (embark-act
  		       embark-dwim
  		       embark-export
  		       embark-collect
  		       embark-bindings
  		       embark-prefix-help-command)
    :init
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none))))
    :bind (:map minibuffer-local-map
                ("M-o"     . embark-act)
                ("C-c C-c" . embark-export)
                ("C-c C-o" . embark-collect)))

  (use-package embark-consult
    :ensure t
    :after (embark consult)
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

*** Eldoc
#+begin_src emacs-lisp
  (use-package eldoc-box
    :ensure t
    :config
    (evil-leader/set-key
      "lh" 'eldoc-box-help-at-point))
#+end_src

*** Marginalia
Annotations for Completion Candidates:
- Marginalia: Adds rich annotations to completion candidates, enhancing the completion experience with additional context.

#+begin_src emacs-lisp
  ;; Annotations for completion candidates.
  (use-package marginalia
    ;; Marginalia allows Embark to offer you preconfigured actions in more contexts.
    ;; In addition to that, Marginalia also enhances Vertico by adding rich
    ;; annotations to the completion candidates displayed in Vertico's interface.
    :ensure t
    :defer t
    :commands (marginalia-mode marginalia-cycle)
    :hook (after-init . marginalia-mode))
#+end_src

*** Orderless
Flexible Matching:
- Orderless: Provides flexible matching capabilities for completion, allowing multiple patterns to be matched in any order.

#+begin_src emacs-lisp
  ;; Space-separated matching components matching in any order.
  (use-package orderless
    ;; Vertico leverages Orderless' flexible matching capabilities, allowing users
    ;; to input multiple patterns separated by spaces, which Orderless then
    ;; matches in any order against the candidates.
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

*** Vertico
Vertical Interactive Completion UI:
- Vertico: Offers a vertical completion interface, improving the user experience for navigating and selecting completion candidates.
- Vertico-Posframe: Provides a posframe handler for Vertico, ensuring the completion interface is displayed in a consistent and visually appealing manner.

#+begin_src emacs-lisp
  ;; Vertical interactive completion UI.
  ;; Tip: You can remove the `vertico-mode' use-package and replace it
  ;;      with the built-in `fido-vertical-mode'.
  (use-package vertico
    ;; (Note: It is recommended to also enable the savehist package.)
    :ensure t
    :defer t
    :commands vertico-mode
    :hook (after-init . vertico-mode))

  (use-package vertico-posframe
    :hook (vertico-mode . vertico-posframe-mode)
    :config
    (setq vertico-posframe-parameters
	'((left-fringe . 8)
	  (right-fringe . 8)))
    (setq vertico-posframe-poshandler #'posframe-poshandler-frame-bottom-right-corner))
#+end_src

** Core
#+begin_src emacs-lisp
  (defvar minimal-emacs-ui-features '()
    "List of user interface features to disable in minimal Emacs setup.

      This variable holds a list Emacs UI features that can be enabled:
      - `context-menu`: Enables the context menu in graphical environments.
      - `tool-bar`: Enables the tool bar in graphical environments.
      - `menu-bar`: Enables the menu bar in graphical environments.
      - `dialogs`: Enables both file dialogs and dialog boxes.
      - `tooltips`: Enables tooltips.

      Each feature in the list corresponds to a specific UI component that can be
      turned on.")

  (defvar minimal-emacs-frame-title-format "%b – Emacs"
    "Template for displaying the title bar of visible and iconified frame.")

  (defvar minimal-emacs-debug nil
    "Non-nil to enable debug.")

  (defvar minimal-emacs-gc-cons-threshold (* 16 1024 1024)
    "The value of `gc-cons-threshold' after Emacs startup.")

  (defvar minimal-emacs-package-initialize-and-refresh t
    "Whether to automatically initialize and refresh packages.
      When set to non-nil, Emacs will automatically call `package-initialize' and
      `package-refresh-contents' to set up and update the package system.")

  (defvar minimal-emacs-user-directory user-emacs-directory
    "The default value of the `user-emacs-directory' variable.")

      ;;; Load pre-early-init.el

  (defun minimal-emacs-load-user-init (filename)
    "Execute a file of Lisp code named FILENAME."
    (let ((user-init-file
           (expand-file-name filename
                             minimal-emacs-user-directory)))
      (when (file-exists-p user-init-file)
        (load user-init-file nil t))))

  (minimal-emacs-load-user-init "pre-early-init.el")

  (setq custom-theme-directory
        (expand-file-name "themes/" minimal-emacs-user-directory))
  (setq custom-file (expand-file-name "custom.el" minimal-emacs-user-directory))

      ;;; Garbage collection
  ;; Garbage collection significantly affects startup times. This setting delays
  ;; garbage collection during startup but will be reset later.

  (setq gc-cons-threshold most-positive-fixnum)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold minimal-emacs-gc-cons-threshold)))

      ;;; Misc

  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8)      ;; Default for new buffers
  (prefer-coding-system 'utf-8)            ;; Prioritize UTF-8 when detecting encoding
  (setq-default buffer-file-coding-system 'utf-8-unix)  ;; Default when saving files

  ;; Set-language-environment sets default-input-method, which is unwanted.
  (setq default-input-method nil)

      ;;; Performance

  ;; Prefer loading newer compiled files
  (setq load-prefer-newer t)

  ;; Font compacting can be very resource-intensive, especially when rendering
  ;; icon fonts on Windows. This will increase memory usage.
  (setq inhibit-compacting-font-caches t)

  (unless (daemonp)
    (let ((old-value (default-toplevel-value 'file-name-handler-alist)))
      (set-default-toplevel-value
       'file-name-handler-alist
       ;; Determine the state of bundled libraries using calc-loaddefs.el.
       ;; If compressed, retain the gzip handler in `file-name-handler-alist`.
       ;; If compiled or neither, omit the gzip handler during startup for
       ;; improved startup and package load time.
       (if (eval-when-compile
             (locate-file-internal "calc-loaddefs.el" load-path))
           nil
         (list (rassq 'jka-compr-handler old-value))))
      ;; Ensure the new value persists through any current let-binding.
      (set-default-toplevel-value 'file-name-handler-alist
                                  file-name-handler-alist)
      ;; Remember the old value to reset it as needed.
      (add-hook 'emacs-startup-hook
                (lambda ()
                  (set-default-toplevel-value
                   'file-name-handler-alist
                   ;; Merge instead of overwrite to preserve any changes made
                   ;; since startup.
                   (delete-dups (append file-name-handler-alist old-value))))
                101))

    (unless noninteractive
      (unless minimal-emacs-debug
        (unless minimal-emacs-debug
          ;; Suppress redisplay and redraw during startup to avoid delays and
          ;; prevent flashing an unstyled Emacs frame.
          ;; (setq-default inhibit-redisplay t) ; Can cause artifacts
          (setq-default inhibit-message t)

          ;; Reset the above variables to prevent Emacs from appearing frozen or
          ;; visually corrupted after startup or if a startup error occurs.
          (defun minimal-emacs--reset-inhibited-vars-h ()
            ;; (setq-default inhibit-redisplay nil) ; Can cause artifacts
            (setq-default inhibit-message nil)
            (remove-hook 'post-command-hook #'minimal-emacs--reset-inhibited-vars-h))

          (add-hook 'post-command-hook
                    #'minimal-emacs--reset-inhibited-vars-h -100))

        (dolist (buf (buffer-list))
          (with-current-buffer buf
            (setq mode-line-format nil)))

        (put 'mode-line-format 'initial-value
             (default-toplevel-value 'mode-line-format))
        (setq-default mode-line-format nil)

        (defun minimal-emacs--startup-load-user-init-file (fn &rest args)
          "Advice for startup--load-user-init-file to reset mode-line-format."
          (unwind-protect
              (progn
                ;; Start up as normal
                (apply fn args))
            ;; If we don't undo inhibit-{message, redisplay} and there's an
            ;; error, we'll see nothing but a blank Emacs frame.
            (setq-default inhibit-message nil)
            (unless (default-toplevel-value 'mode-line-format)
              (setq-default mode-line-format
                            (get 'mode-line-format 'initial-value)))))

        (advice-add 'startup--load-user-init-file :around
                    #'minimal-emacs--startup-load-user-init-file))

      ;; Without this, Emacs will try to resize itself to a specific column size
      (setq frame-inhibit-implied-resize t)

      ;; A second, case-insensitive pass over `auto-mode-alist' is time wasted.
      ;; No second pass of case-insensitive search over auto-mode-alist.
      (setq auto-mode-case-fold nil)

      ;; Reduce *Message* noise at startup. An empty scratch buffer (or the
      ;; dashboard) is more than enough, and faster to display.
      (setq inhibit-startup-screen t
            inhibit-startup-echo-area-message user-login-name)
      (setq initial-buffer-choice nil
            inhibit-startup-buffer-menu t
            inhibit-x-resources t)

      ;; Disable bidirectional text scanning for a modest performance boost.
      (setq-default bidi-display-reordering 'left-to-right
                    bidi-paragraph-direction 'left-to-right)

      ;; Give up some bidirectional functionality for slightly faster re-display.
      (setq bidi-inhibit-bpa t)

      ;; Remove "For information about GNU Emacs..." message at startup
      (advice-add #'display-startup-echo-area-message :override #'ignore)

      ;; Suppress the vanilla startup screen completely. We've disabled it with
      ;; `inhibit-startup-screen', but it would still initialize anyway.
      (advice-add #'display-startup-screen :override #'ignore)

      ;; Shave seconds off startup time by starting the scratch buffer in
      ;; `fundamental-mode'
      (setq initial-major-mode 'fundamental-mode
            initial-scratch-message nil)

      (unless minimal-emacs-debug
        ;; Unset command line options irrelevant to the current OS. These options
        ;; are still processed by `command-line-1` but have no effect.
        (unless (eq system-type 'darwin)
          (setq command-line-ns-option-alist nil))
        (unless (memq initial-window-system '(x pgtk))
          (setq command-line-x-option-alist nil)))))

      ;;; Native compilation and Byte compilation

  (if (and (featurep 'native-compile)
           (fboundp 'native-comp-available-p)
           (native-comp-available-p))
      ;; Activate `native-compile'
      (setq native-comp-jit-compilation t
            native-comp-deferred-compilation t  ; Obsolete since Emacs 29.1
            package-native-compile t)
    ;; Deactivate the `native-compile' feature if it is not available
    (setq features (delq 'native-compile features)))

  ;; Suppress compiler warnings and don't inundate users with their popups.
  (setq native-comp-async-report-warnings-errors
        (or minimal-emacs-debug 'silent))
  (setq native-comp-warning-on-missing-source minimal-emacs-debug)

  (setq debug-on-error minimal-emacs-debug
        jka-compr-verbose minimal-emacs-debug)

  (setq byte-compile-warnings minimal-emacs-debug)
  (setq byte-compile-verbose minimal-emacs-debug)

      ;;; UI elements

  (setq frame-title-format minimal-emacs-frame-title-format
        icon-title-format minimal-emacs-frame-title-format)

  ;; Disable startup screens and messages
  (setq inhibit-splash-screen t)

  ;; I intentionally avoid calling `menu-bar-mode', `tool-bar-mode', and
  ;; `scroll-bar-mode' because manipulating frame parameters can trigger or queue
  ;; a superfluous and potentially expensive frame redraw at startup, depending
  ;; on the window system. The variables must also be set to `nil' so users don't
  ;; have to call the functions twice to re-enable them.
  (unless (memq 'menu-bar minimal-emacs-ui-features)
    (push '(menu-bar-lines . 0) default-frame-alist)
    (unless (memq window-system '(mac ns))
      (setq menu-bar-mode nil)))

  (unless (daemonp)
    (unless noninteractive
      (when (fboundp 'tool-bar-setup)
        ;; Temporarily override the tool-bar-setup function to prevent it from
        ;; running during the initial stages of startup
        (advice-add #'tool-bar-setup :override #'ignore)
        (define-advice startup--load-user-init-file
            (:after (&rest _) minimal-emacs-setup-toolbar)
          (advice-remove #'tool-bar-setup #'ignore)
          (when tool-bar-mode
            (tool-bar-setup))))))
  (unless (memq 'tool-bar minimal-emacs-ui-features)
    (push '(tool-bar-lines . 0) default-frame-alist)
    (setq tool-bar-mode nil))

  (push '(vertical-scroll-bars) default-frame-alist)
  (push '(horizontal-scroll-bars) default-frame-alist)
  (setq scroll-bar-mode nil)
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))

  (unless (memq 'tooltips minimal-emacs-ui-features)
    (when (bound-and-true-p tooltip-mode)
      (tooltip-mode -1)))

  ;; Disable GUIs because they are inconsistent across systems, desktop
  ;; environments, and themes, and they don't match the look of Emacs.
  (unless (memq 'dialogs minimal-emacs-ui-features)
    (setq use-file-dialog nil)
    (setq use-dialog-box nil))

      ;;; LSP
  (setenv "LSP_USE_PLISTS" "true")

  ;; Disable sound bell
  (setq visible-bell       nil
        ring-bell-function #'ignore)


  ;; Ensure Emacs loads the most recent byte-compiled files.
  (setq load-prefer-newer t)

  ;; Ensure JIT compilation is enabled for improved performance by
  ;; native-compiling loaded .elc files asynchronously
  (setq native-comp-jit-compilation t)
  					;(setq native-comp-deferred-compilation t) ; Deprecated in Emacs > 29.1

  					;(use-package compile-angel
  					;  :ensure t
  					;  :demand t
  					;  :config
  					;  (compile-angel-on-load-mode)
  					;  (add-hook 'emacs-lisp-mode-hook #'compile-angel-on-save-local-mode))

  ;; Auto-revert in Emacs is a feature that automatically updates the
  ;; contents of a buffer to reflect changes made to the underlying file
  ;; on disk.
  (add-hook 'after-init-hook #'global-auto-revert-mode)

  ;; recentf is an Emacs package that maintains a list of recently
  ;; accessed files, making it easier to reopen files you have worked on
  ;; recently.
  (add-hook 'after-init-hook #'recentf-mode)

  ;; savehist is an Emacs feature that preserves the minibuffer history between
  ;; sessions. It saves the history of inputs in the minibuffer, such as commands,
  ;; search strings, and other prompts, to a file. This allows users to retain
  ;; their minibuffer history across Emacs restarts.
  (add-hook 'after-init-hook #'savehist-mode)

  ;; save-place-mode enables Emacs to remember the last location within a file
  ;; upon reopening. This feature is particularly beneficial for resuming work at
  ;; the precise point where you previously left off.
  (add-hook 'after-init-hook #'save-place-mode)

  ;; Turn on which-key-mode
  (add-hook 'after-init-hook 'which-key-mode)

  ;; Turn off autosave-mode
  ;; turn off backup-files
  (auto-save-mode -1)
  (setq make-backup-files nil)
  (setq auto-save-default nil)

    ;;; Line numbers
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode)

    ;;; Set auto pair mode
  (electric-pair-mode 1)
#+end_src

** Document

Document reader using pdf-tools and org-pdfview

#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :hook (pdf-view-mode . (lambda ()
  			     (display-line-numbers-mode -1)))
    :config
    (pdf-tools-install)
    (setq-default pdf-view-display-size 'fit-page))
#+end_src

** Edit

Formatters:
- Apheleia: Provides on-the-fly code formatting using various formatters:
  -  Scalafmt for Scala
  -  Black for Python
  -  Prettier for TypeScript and JavaScript
  -  Google Java Format for Java
  -  nixpkgs-fmt for Nix

#+begin_src emacs-lisp
  ;; Formatters
  (use-package apheleia
    :config
    ;; Add scalafmt for Scala
    (push '(scalafmt . ("scalafmt" "--stdin" "--non-interactive" "--quiet" "--stdout")) apheleia-formatters)
    (push '(scala-ts-mode . scalafmt) apheleia-mode-alist)

    ;; Add black for Python
    (push '(black . ("black" "-")) apheleia-formatters)
    (push '(python-mode . black) apheleia-mode-alist)

    ;; Add prettier for TypeScript and JavaScript
    (push '(prettier . ("prettier" "--stdin-filepath" buffer-file-name)) apheleia-formatters)
    (push '(typescript-ts-mode . prettier) apheleia-mode-alist)
    (push '(js-ts-mode . prettier) apheleia-mode-alist)

    ;; Add google-java-format for Java
    (push '(google-java-format . ("google-java-format" "-")) apheleia-formatters)
    (push '(java-ts-mode . google-java-format) apheleia-mode-alist)

    ;; Add nixpkgs-fmt for Nix
    (push '(nixpkgs-fmt . ("nixpkgs-fmt")) apheleia-formatters)
    (push '(nix-mode . nixpkgs-fmt) apheleia-mode-alist))

  (apheleia-global-mode +1)
#+end_src

** Email

#+BEGIN_QUOTE
Email should be a seamless part of your workflow, not a constant distraction. This setup combines the power of mu4e, mbsync, and msmtp to create a fast, efficient, and distraction-free email experience directly in Emacs.
#+END_QUOTE

My email configuration transforms Emacs into a powerful email client with several key advantages:

+ *Efficiency*: Read, compose, and organize email without leaving Emacs
+ *Speed*: Direct access to local mail storage for instant searches and views
+ *Privacy*: Complete control over your email data with encryption support
+ *Integration*: Seamlessly connect email with notes, tasks, and calendar
+ *Distraction-free*: Batch process email on your schedule, not the inbox's

*** Mu4e
#+begin_src emacs-lisp
  (use-package mu4e
    :ensure t
    :defer 20
    :config
    (setq mu4e-change-filenames-when-moving t
  	  mu4e-update-interval (* 10 60)
  	  mu4e-compose-format-flowed t
  	  mu4e-get-mail-command "mbsync -a"
  	  mu4e-maildir "~/Mail")

    (setq mu4e-drafts-folder "/personal/Drafts"
          mu4e-sent-folder   "/personal/Sent"
          mu4e-trash-folder  "/personal/Trash"
          mu4e-refile-folder "/personal/Archive")

    (setq mu4e-maildir-shortcuts
          '(("/personal/INBOX"     . ?i)
            ("/personal/Sent"      . ?s)
            ("/personal/Trash"     . ?t)
            ("/personal/Drafts"    . ?d)
            ("/personal/Archive"   . ?a)
            ("/personal/All Mail"  . ?m)
            ("/personal/Spam"      . ?j)
            ("/personal/Starred"   . ?★)))

    (setq send-mail-function 'sendmail-send-it
          message-send-mail-function 'sendmail-send-it
          sendmail-program "msmtp"
          message-sendmail-extra-arguments '("--read-envelope-from")
          message-sendmail-f-is-evil t)

    (setq user-mail-address "merrinx@proton.me"
          user-full-name "merrinx")

    (defun my-set-alias-when-replying ()
      "Automatically set the From address to match the To address of the message being replied to."
      (when mu4e-compose-parent-message
        (let* ((to-field (mu4e-message-field mu4e-compose-parent-message :to))
               (to-addr (when to-field
                          (caar to-field)))
               (aliases '("mugge.acrobat989@passinbox.com"
                          "gako.footwork856@passinbox.com"
                          "knut.sly692@passinbox.com")))
          (when (and to-addr (member to-addr aliases))
            (setq user-mail-address to-addr)
            (message "Replying with alias: %s" to-addr)))))

    (add-hook 'mu4e-compose-pre-hook 'my-set-alias-when-replying))
#+end_src
*** Mu4e-Alert
#+begin_src emacs-lisp
  (use-package mu4e-alert
    :ensure t
    :after mu4e
    :config
    (mu4e-alert-set-default-style 'notifications)
    (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display)
    (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
    (setq mu4e-alert-email-notification-types '(count subjects))
    (setq mu4e-alert-interesting-mail-query
  	  "flag:unread AND NOT flag:trashed"))
#+end_src

** Evil
*** Evil Mode
#+begin_src emacs-lisp
  ;; evil-want-keybinding must be declared before Evil and Evil Collection
  (setq evil-want-keybinding nil)

  (use-package evil
    :ensure t
    :init
    (setq evil-want-integration t)
    :custom
    (evil-want-Y-yank-to-eol t)
    :config
    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-mode 1))

  ;; Define scroll up
  (define-key evil-normal-state-map (kbd "C-u") 'evil-scroll-up)
  (define-key evil-visual-state-map (kbd "C-u") 'evil-scroll-up)
  (define-key evil-insert-state-map (kbd "C-u")
        	    (lambda ()
        	      (interactive)
        	      (evil-delete (point-at-bol) (point))))

  ;; Evil numbers inc and dec
  (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-visual-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-i") 'evil-numbers/dec-at-pt)
  (define-key evil-visual-state-map (kbd "C-i") 'evil-numbers/dec-at-pt)
  ;; Redefine keys for switching windows
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
#+end_src

*** Evil Collection
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :ensure t
    :hook (evil-mode . evil-collection-init)
    :bind (([remap evil-show-marks] . evil-collection-consult-mark)
  	   ([remap evil-show-jumps] . evil-collection-consult-jump-list))
    :config
    ;; Make `evil-collection-consult-mark' and `evil-collection-consult-jump-list'
    ;; immediately available.
    (evil-collection-require 'consult)
    :custom
    (evil-collection-setup-debugger-keys nil)
    (evil-collection-calendar-want-org-bindings t)
    (evil-collection-unimpaired-want-repeat-mode-integration t))
#+end_src

*** Evil Comment
#+begin_src emacs-lisp
  (with-eval-after-load "evil"
    (evil-define-operator my-evil-comment-or-uncomment (beg end)
      "Toggle comment for the region between BEG and END."
      (interactive "<r>")
      (comment-or-uncomment-region beg end))
    (evil-define-key 'normal 'global (kbd "gc") 'my-evil-comment-or-uncomment))
#+end_src

*** Evil Leader
#+begin_src emacs-lisp
  (use-package evil-leader
    :ensure t
    :config
    (global-evil-leader-mode)
    (evil-leader/set-leader "<SPC>"))
#+end_src

*** Evil Multi-Cursor
#+begin_src emacs-lisp
  (use-package evil-mc
    :ensure t
    :after evil
    :config
    (global-evil-mc-mode 1)
    (setq evil-mc-one-cursor-show-mode-line-text nil)
    (setq evil-mc-undo-cursors-on-keyboard-quit nil))

  (use-package evil-mc-extra
    :ensure t
    :after evil-mc)
#+end_src

*** Evil Surround
#+begin_src emacs-lisp
  (use-package evil-surround
    :after evil
    :ensure t
    :defer t
    :commands global-evil-surround-mode
    :custom
    (evil-surround-pairs-alist
     '((?\( . ("(" . ")"))
       (?\[ . ("[" . "]"))
       (?\{ . ("{" . "}"))

       (?\) . ("(" . ")"))
       (?\] . ("[" . "]"))
       (?\} . ("{" . "}"))

       (?< . ("<" . ">"))
       (?> . ("<" . ">"))))
    :hook (after-init . global-evil-surround-mode))
#+end_src

*** Evil Visual Star
#+begin_src emacs-lisp
  (use-package evil-visualstar
    :after evil
    :ensure t
    :defer t
    :commands global-evil-visualstar-mode
    :hook (after-init . global-evil-visualstar-mode))
#+end_src

** General
*** Dependencies
#+begin_src emacs-lisp
  (use-package dash :ensure t)
  (use-package s :ensure t)
  (use-package editorconfig
    :ensure t
    :config
    (editorconfig-mode 1))
  (use-package f :ensure t)
  (use-package ansi-color
    :hook (compilation-filter . ansi-color-compilation-filter))
#+end_src

*** direnv
#+begin_src emacs-lisp
  ;;; Direnv integration
  (use-package envrc
    :hook (after-init . envrc-global-mode))
#+end_src

*** Grep
Writable Grep:
- wgrep: Allows editing of grep buffers, enabling changes to be applied directly to files.

#+begin_src emacs-lisp
  (use-package wgrep)

  (evil-leader/set-key
    "we" 'wgrep-change-to-wgrep-mode
    "ws" 'wgrep-finish-edit)
#+end_src

*** Midnight
Midnight package: Automatically cleans up unused buffers daily at 4:30am.
- The following regexps ensure special and important buffers (tramp, minibuffer,
- auto-save, directory, and all mu4e mail buffers) are never killed automatically.

#+begin_src emacs-lisp
  (use-package midnight
    :ensure t
    :config
    (custom-set-variables
     '(clean-buffer-list-delay-special 86400) ;; Buffers not used last 24h
     '(clean-buffer-list-kill-never-regexps
       '(
  	 "^\\*tramp/.*\\*$"
  	 "^ \\*Minibuf-.*\\*$"
  	 "^#.*$"
  	 "^\\*\\*df.\\*\\**$"
  	 "^\\*mu4e-.*\\*$"
  	 )))
    (midnight-delay-set 'midnight-delay "4:30am"))
#+end_src

*** Proced
Proced is Emacs' built-in process manager, providing a powerful interface for monitoring and managing system processes directly within Emacs. This configuration transforms the basic proced into a feature-rich system monitor comparable to htop or top.

+ Key Features:
- *Visual Enhancements*: Colored output with automatic highlighting of high CPU (>50%, red) and memory (>20%, yellow) usage
- *Auto-refresh*: Processes update every 5 seconds automatically (toggle with 'a')
- *Tree View*: Shows parent-child process relationships by default (toggle with 'l')
- *Multiple Formats*: Switch between different views - short, medium, long, verbose, performance, and admin formats (cycle with 'F')
- *Smart Filtering*: Quick filters for user processes (/ u) or all processes (/ c)
- *Efficient Sorting*: Sort by CPU (s c), memory (s m), PID (s p), time (s t), or start time (s s)

+ Custom Functions:
- =my/proced-show-active=: Filters to show only active processes (CPU > 1% or Memory > 5%)
- =my/proced-kill-process-by-name=: Kill all processes matching a name pattern
- =my/proced-highlight-high-usage=: Automatically highlights resource-intensive processes

+ Keybindings:
- =C-x p p=: Launch proced from anywhere
- =j/k=: Vim-style navigation
- =K=: Kill process with signal selection
- =r=: Renice (adjust process priority)
- =g=: Manual refresh
- =G=: Full revert

This configuration makes system monitoring and process management seamless within Emacs, eliminating the need to switch to a terminal for basic system administration tasks.
#+begin_src emacs-lisp
  (use-package proced
    :ensure nil
    :defer t
    :custom
    (proced-enable-color-flag t)
    (proced-tree-flag t)
    (proced-filter 'all)
    (proced-sort 'pcpu)
    (proced-format-memory-flag t)
    (proced-format-alist
     '((short user pid tree pcpu pmem start time (args comm))
       (medium user pid tree pcpu pmem vsize rss ttname state start time (args comm))
       (long user euid group pid tree pri nice pcpu pmem vsize rss ttname state start time (args comm))
       (verbose user euid group egid pid ppid tree pgrp sess pri nice pcpu pmem state thcount vsize rss ttname tpgid minflt majflt cminflt cmajflt start time utime stime ctime cutime cstime etime (args comm))
       (performance pid tree pcpu pmem vsize rss state time (args comm))
       (admin user pid ppid tree nice pcpu pmem state start time (args comm))))

    (proced-format 'medium)

    :bind
    ("C-x p p" . proced)

    :config
    (evil-set-initial-state 'proced-mode 'normal)
    (evil-define-key 'normal proced-mode-map
      ;; Navigation
      "j" 'next-line
      "k" 'previous-line
      "gg" 'beginning-of-buffer
      "G" 'end-of-buffer
      "l" 'proced-toggle-tree

      ;; Updates
      "gr" 'proced-update
      "gR" 'proced-revert
      "a" 'proced-toggle-auto-update

      ;; Marking
      "m" 'proced-mark
      "u" 'proced-unmark
      "U" 'proced-unmark-all
      "t" 'proced-toggle-marks

      ;; Actions
      "d" 'proced-send-signal
      "D" (lambda () (interactive) (proced-send-signal 'KILL))
      "x" 'proced-send-signal
      "K" 'proced-send-signal
      "r" 'proced-renice

      ;; Format switching
      "F" 'proced-format-interactive

      ;; Custom functions
      "X" 'my/proced-kill-process-by-name

      ;; Other
      "?" 'describe-mode
      "h" 'describe-mode
      "q" 'quit-window)

    ;; Visual mode for marking multiple processes
    (evil-define-key 'visual proced-mode-map
      "m" 'proced-mark
      "u" 'proced-unmark
      "d" 'proced-send-signal
      "x" 'proced-send-signal)

    ;; Face customization
    (set-face-attribute 'proced-mark nil
                        :background "#3c3836"
                        :foreground "#fb4934"
                        :weight 'bold)

    (defun my/proced-highlight-high-usage ()
      "Highlight processes with high CPU or memory usage."
      (save-excursion
        (goto-char (point-min))
        (while (not (eobp))
          (let ((line (thing-at-point 'line t)))
            (when line
              (when (string-match "\\s-\\([5-9][0-9]\\|100\\)\\.[0-9]\\s-" line)
                (put-text-property (line-beginning-position) (line-end-position)
                                   'face '(:foreground "#fb4934")))
              (when (string-match "\\s-\\(2[0-9]\\|[3-9][0-9]\\|100\\)\\.[0-9]\\s-" line)
                (unless (get-text-property (line-beginning-position) 'face)
                  (put-text-property (line-beginning-position) (line-end-position)
                                     'face '(:foreground "#fabd2f"))))))
          (forward-line 1))))

    (add-hook 'proced-post-display-hook #'my/proced-highlight-high-usage)

    (defun my/proced-kill-process-by-name (name)
      "Kill all processes matching NAME."
      (interactive "sProcess name: ")
      (proced)
      (proced-filter-interactive 'all)
      (goto-char (point-min))
      (let ((count 0))
        (while (search-forward name nil t)
          (when (save-excursion
                  (beginning-of-line)
                  (looking-at "^\\s-*\\S-+\\s-+\\([0-9]+\\)"))
            (proced-mark)
            (setq count (1+ count))))
        (when (> count 0)
          (proced-send-signal 'TERM)
          (message "Sent TERM signal to %d process(es)" count))))

    (defun my/proced-show-active ()
      "Show only processes that are actively using CPU or have high memory usage."
      (interactive)
      (proced-filter-interactive
       (lambda (proc)
         (let ((pcpu (cdr (assq 'pcpu (process-attributes proc))))
               (pmem (cdr (assq 'pmem (process-attributes proc)))))
           (or (and pcpu (> pcpu 1.0))
               (and pmem (> pmem 5.0)))))))

    (easy-menu-define proced-custom-menu proced-mode-map
      "Custom menu for Proced mode"
      '("Proced"
        ["Show Active Processes" my/proced-show-active t]
        ["Kill by Name" my/proced-kill-process-by-name t]
        "---"
        ["Toggle Tree View" proced-toggle-tree t]
        ["Toggle Auto Update" proced-toggle-auto-update t])))
#+end_src

** Grammars
*** Flyspell dictionary
#+begin_src emacs-lisp
  (use-package flyspell
    :ensure nil
    :init
    (setq ispell-program-name "hunspell")
    :config
    ;; The actual dictionary names based on the .aff files found
    (setq ispell-local-dictionary-alist
  	'(("en_GB" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_GB") nil utf-8)
  	  ("nb_NO" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "nb_NO") nil utf-8)))

    ;; Set default dictionary (use en_GB, not en_GB-ise)
    (setq ispell-dictionary "en_GB"
  	ispell-local-dictionary "en_GB")

    ;; Tell hunspell to use multiple dictionaries if needed
    (setq ispell-hunspell-dictionary-alist ispell-local-dictionary-alist)

    ;; Hooks to enable flyspell in the desired modes
    (dolist (hook '(org-mode-hook text-mode-hook markdown-mode-hook))
      (add-hook hook #'flyspell-mode))
    (add-hook 'prog-mode-hook #'flyspell-prog-mode)

    ;; Dictionary switching functions
    (defun my/switch-to-english ()
      "Switch to British English dictionary."
      (interactive)
      (ispell-change-dictionary "en_GB")
      (setq ispell-dictionary "en_GB"
  	    ispell-local-dictionary "en_GB")
      (when (bound-and-true-p flyspell-mode)
  	(flyspell-buffer))
      (message "Switched to British English (en_GB)"))

    (defun my/switch-to-norwegian ()
      "Switch to Norwegian Bokmål dictionary."
      (interactive)
      (ispell-change-dictionary "nb_NO")
      (setq ispell-dictionary "nb_NO"
    	  ispell-local-dictionary "nb_NO")
      (when (bound-and-true-p flyspell-mode)
        (flyspell-buffer))
      (message "Switched to Norwegian Bokmål (nb_NO)"))

    (defun my/toggle-dictionary ()
      "Toggle between British English and Norwegian dictionaries."
      (interactive)
      (let ((cur (or ispell-current-dictionary ispell-local-dictionary ispell-dictionary)))
        (if (string= cur "en_GB")
    	  (my/switch-to-norwegian)
    	(my/switch-to-english))))

    ;; Keybindings for switching
    (global-set-key (kbd "C-c d e") #'my/switch-to-english)
    (global-set-key (kbd "C-c d n") #'my/switch-to-norwegian)
    (global-set-key (kbd "C-c d t") #'my/toggle-dictionary)

    ;; If hunspell is available, prefer it explicitly
    (when (executable-find "hunspell")
      (setq ispell-really-hunspell t)))
#+end_src

*** Setting up treesitter grammars
#+begin_src emacs-lisp
  (use-package treesit
    :ensure nil
    :custom
    (treesit-font-lock-level 4) ;; Set font lock level for Tree-sitter
    :config
    (seq-do (lambda (it)
  	      (push it major-mode-remap-alist))
  	    '((css-mode . css-ts-mode) ;; Remap CSS mode to Tree-sitter mode
  	      (c-mode . c-ts-mode) ;; Remap C mode to Tree-sitter mode
  	      (dockerfile-mode . dockerfile-ts-mode) ;; Remap Dockerfile mode to Tree-sitter mode
  	      (haskell-mode . haskell-ts-mode) ;; Remap Haskell mode to Tree-sitter mode
  	      (java-mode . java-ts-mode) ;; Remap Java mode to Tree-sitter mode
  	      (javascript-mode . js-ts-mode) ;; Remap JavaScript mode to Tree-sitter mode
  	      (kotlin-mode . kotlin-ts-mode) ;; Remap Kotlin mode to Tree-sitter mode
  	      (python-mode . python-ts-mode) ;; Remap Python mode to Tree-sitter mode
  	      (scala-mode . scala-ts-mode) ;; Remap Scala mode to Tree-sitter mode
  	      (sh-mode . bash-ts-mode) ;; Remap Shell Script mode to Tree-sitter mode
  	      (shell-script-mode . bash-ts-mode) ;; Remap Shell Script mode to Tree-sitter mode
  	      (typescript-mode . typescript-ts-mode) ;; Remap TypeScript mode to Tree-sitter mode
  	      (yaml-mode . yaml-ts-mode)))) ;; Remap YAML mode to Tree-sitter mode
#+end_src
** Filetree
#+begin_src emacs-lisp
  (use-package dirvish
    :ensure t
    :init
    (dirvish-override-dired-mode)
    :config
    (setq dirvish-mode-line-format
  	  '(:left (sort symlink) :right (omit yank index)))
    (setq dirvish-attributes           ; The order *MATTERS* for some attributes
  	  '(vc-state subtree-state nerd-icons collapse git-msg file-time file-size)
  	  dirvish-side-attributes
  	  '(vc-state nerd-icons collapse file-size))
    (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
  	  "-l --almost-all --human-readable --group-directories-first --no-group")
    :bind ; Bind `dirvish-fd|dirvish-side|dirvish-dwim' as you see fit
    (
     :map dirvish-mode-map          ; Dirvish inherits `dired-mode-map'
     ("M-f"   . dirvish-file-info-menu)
     ("M-y"   . dirvish-yank-menu)
     ("M-h" . dired-up-directory)
     ("M-n" . dired-create-empty-file)
     ("M-v"   . dirvish-vc-menu)      ; remapped `dired-view-file'
     ("M-o" . dirvish-subtree-toggle)
     ("M-l" . dirvish-ls-switches-menu)
     ("M-m" . dirvish-mark-menu)
     ("M-t" . dirvish-layout-toggle)
     ("M-s" . dirvish-setup-menu)
     ("M-e" . dirvish-emerge-menu)
     ("M-q" . dirvish-quit)
     ("M-j" . dirvish-fd-jump)))

  (add-hook 'dired-mode-hook 'auto-revert-mode)
  (add-hook 'dirvish-setup-hook (lambda ()
                                  (visual-line-mode -1)
                                  (setq-local truncate-lines t)))

  (evil-leader/set-key
    "rf" 'dirvish)
#+end_src

** Keybindings

Custom keymaps
#+begin_src emacs-lisp
  ;; Kill all buffers except current working buffer
  (defun kill-other-buffers ()
    "Kill all other buffers."
    (interactive)
    (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))

  (defun projectile-kill-other-buffers ()
    "Kill all buffers in current project except for current buffer."
    (interactive)
    (let* ((current-buffer (current-buffer))
  	 (buffers (projectile-project-buffers)))
      (dolist (buffer buffers)
        (unless (eq buffer current-buffer)
  	(kill-buffer buffer)))))

  ;; Kill all dired buffers
  (defun kill-dired-buffers ()
    (interactive)
    (mapc (lambda (buffer)
        	  (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
        	    (kill-buffer buffer)))
        	(buffer-list)))


  (defun my/projectile-switch-to-buffer-with-vterm ()
    "Switch to a buffer whose name includes 'vterm using consult-projectile."
    (interactive)
    (let ((filtered-buffers (seq-filter (lambda (buf)
    					(string-match-p "vterm" (buffer-name buf)))
    				      (projectile-project-buffers))))
      (if filtered-buffers
    	(consult--read (mapcar #'buffer-name filtered-buffers)
    		       :prompt "Switch to terminal: "
    		       :require-match t
    		       :sort nil
    		       :category 'buffer
    		       :history 'buffer-name-history
    		       :state (consult--buffer-state))
        (message "No buffers found with term: %s" "vterm"))))

  (defun my/consult-projectile-grep-at-point ()
    "Use consult to grep for the word at point within the projectile files. If a region is selected, use the selected text instead."
    (interactive)
    (let ((search-term (if (use-region-p)
              		 (buffer-substring-no-properties (region-beginning) (region-end))
              	       (let* ((word (thing-at-point 'word t))
              		      (bounds (bounds-of-thing-at-point 'symbol))
              		      (symbol (buffer-substring-no-properties (car bounds) (cdr bounds))))
              		 (if (or (string-match-p "-" word) (string-match-p "_" word))
              		     symbol
              		   word)))))
      (consult-ripgrep (projectile-project-root) search-term)))

  (defun my/switch-to-previous-buffer ()
    "Switch to the most recently visited buffer in the current Projectile project.
    If no previous buffer is detected in the same project, then call
    `consult-projectile-switch-to-buffer' as a fallback."
    (interactive)
    (let* ((current-project (projectile-project-root))
    	 ;; Get all buffers that are visiting files and belong to the current project.
    	 (project-buffers
    	  (seq-filter
    	   (lambda (buf)
    	     (with-current-buffer buf
    	       (when (buffer-file-name)
    		 (and current-project
    		      (string= (projectile-project-root (buffer-file-name)) current-project))))
    	     )
    	   (buffer-list))))
      (if (and project-buffers (> (length project-buffers) 1))
    	;; "nth 1" gives the second most recent buffer since the current buffer is the first.
    	(switch-to-buffer (nth 1 project-buffers))
        (message "No previous buffer in the current project; using consult-projectile-switch-to-buffer.")
        (call-interactively #'consult-projectile-switch-to-buffer))))


  (defun my/consult-replace-word-with-preview ()
    "Replace occurrences of word under cursor using consult for visualization."
    (interactive)
    (let* ((bounds (if (evil-visual-state-p)
        		     (cons (region-beginning) (region-end))
        		   (bounds-of-thing-at-point 'word)))
        	 (word (when bounds
        		 (buffer-substring-no-properties (car bounds) (cdr bounds)))))
      (when word
        (if (evil-visual-state-p)
        	  (evil-normal-state))
        ;; First show the occurrences with consult-ripgrep
        (consult-ripgrep nil (regexp-quote word))
        ;; After viewing, prompt for replacement
        (let ((new-word (read-string (format "Replace \"%s\" with: " word))))
        	(when new-word
        	  (evil-ex (format "%%s/%s/%s/gc"
        			   (regexp-quote word)
        			   new-word)))))))


  (defun my/consult-replace-word-in-buffer ()
    "Replace word under cursor with preview using consult-line."
    (interactive)
    (let* ((bounds (if (evil-visual-state-p)
      		     (cons (region-beginning) (region-end))
      		   (bounds-of-thing-at-point 'word)))
      	 (word (when bounds
      		 (buffer-substring-no-properties (car bounds) (cdr bounds)))))
      (when word
        (if (evil-visual-state-p)
      	  (evil-normal-state))
        ;; Show occurrences with consult-line
        (consult-line (regexp-quote word))
        ;; After viewing, prompt for replacement
        (let ((new-word (read-string (format "Replace \"%s\" with: " word))))
      	(when new-word
      	  (evil-ex (format "%%s/%s/%s/gc"
      			   (regexp-quote word)
      			   new-word)))))))

  (evil-leader/set-key
    "SPC" 'my/consult-projectile-grep-at-point
    "DEL" 'kill-buffer
    "ka" 'kill-other-buffers
    "kp" 'projectile-kill-other-buffers
    "kd" 'kill-dired-buffers
    "tr" 'rename-buffer
    "tl" 'my/projectile-switch-to-buffer-with-vterm
    "sb" 'my/consult-replace-word-with-preview
    "sr" 'my/consult-replace-word-in-buffer)

  (global-set-key (kbd "<C-tab>") #'my/switch-to-previous-buffer)
#+end_src

** Languages
Using Eglot, Emacs built-in LSP client.
Setup using:
- C
- Dockerfile
- Haskell
- Java
- Kotlin
- Markdown
- Nix
- Rust
- SBT and Scala
- SQL
- Typescript
- Yaml

Using own created web mode, for Vue, TypeScript, and Tailwind.

*** C
#+begin_src emacs-lisp
  ;; C language server
  (use-package c-ts-mode
    :hook (c-ts-mode . eglot-ensure)
    :mode (("\\.c\\'" . c-ts-mode)
	   ("\\.h\\'" . c-ts-mode)))
    #+end_src

*** Dockerfile

#+begin_src emacs-lisp
  (use-package dockerfile-ts-mode)
#+end_src

*** Haskell
#+begin_src emacs-lisp
  (use-package haskell-ts-mode
    :ensure t
    :custom
    (haskell-ts-use-indent t)
    (haskell-ts-ghci "ghci")
    :mode (("\\.hs\\'" . haskell-ts-mode)
  	 ("\\.cabal\\'" . haskell-ts-mode)))
#+end_src

*** Java
#+begin_src emacs-lisp
  ;; Java language server
  (use-package eglot-java
    :init
    :hook (java-ts-mode . eglot-java-mode))

  (with-eval-after-load 'eglot-java
    (evil-leader/set-key
      "ljn" 'eglot-java-file-new
      "ljx" 'eglot-java-run-main
      "ljt" 'eglot-java-run-test
      "ljN" 'eglot-java-project-new
      "ljT" 'eglot-java-project-build-task
      "ljR" 'eglot-java-project-build-refresh))

#+end_src

*** Kotlin
#+begin_src emacs-lisp
  (use-package kotlin-ts-mode
    :init
    :hook (kotlin-ts-mode . eglot-ensure)
    :mode "\\.kt\\'")

  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
  	       '(kotlin-ts-mode .("kotlin-language-server"))))
#+end_src

*** Markdown
Markdown Edit:
- Markdown Mode: Provides support for editing markdown files, enhancing the writing and formatting experience.

#+begin_src emacs-lisp
  ;; Markdown edit
  (use-package markdown-mode)
#+end_src

*** Nix
#+begin_src emacs-lisp
  (use-package nix-ts-mode
    :mode "\\.nix\\'"
    :hook ((nix-ts-mode . eglot-ensure)
  	 (before-save . eglot-format-buffer)
  	 (before-save . nixpkgs-fmt-before-save)))

  (defun nixpkgs-fmt-before-save ()
    "Format the current buffer with nixpkgs-fmt if it is available."
    (when (eq major-mode 'nix-ts-mode)
      (if (executable-find "nixpkgs-fmt")
	  (let ((output-buffer (get-buffer-create "*nixpkgs-fmt*")))
	    (shell-command-on-region (point-min) (point-max) "nixpkgs-fmt" output-buffer t)
	    (kill-buffer output-buffer))
	(message "nixpkgs-fmt not found in PATH, skipping formatting."))))

  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(nix-ts-mode . ("nil" "--stdio"))))
#+end_src

*** Rust
#+begin_src emacs-lisp
  ;; Rust language server
  (use-package rust-ts-mode
    :mode "\\.rs\\'"
    :hook
    (rust-ts-mode-hook . eglot-ensure)
    :init
    (with-eval-after-load 'org
      (cl-pushnew '("rust" . rust-ts-mode) org-src-lang-modes :test #'equal)))
#+end_src

*** Scala
#+begin_src emacs-lisp
  ;; Scala language server
  (use-package scala-ts-mode
    :init
    (setq scala-ts-indent-offset 2)
    :hook (before-save . eglot-format-buffer))

  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(scala-ts-mode . ("metals" :initializationOptions (:defaultBspToBuildTool t)))))
#+end_src

*** SQL
#+begin_src emacs-lisp
  ;; SQL syntax-based indentation
  (use-package sql-indent
    :ensure t
    :hook (sql-mode . sqlind-minor-mode))

  (with-eval-after-load 'sql-indent
    (add-hook 'sql-mode-hook 'sqlind-minor-mode))
#+end_src

*** TypeScript
#+begin_src emacs-lisp
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flymake-mode +1)
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1))

  ;; formats the buffer before saving
  (add-hook 'before-save-hook 'tide-format-before-save)
  (add-hook 'typescript-ts-mode-hook #'setup-tide-mode)

  ;; for js-ts-mode with eglot
  (use-package js-ts-mode
    :after eglot
    :hook (js-ts-mode . eglot-ensure)
    :mode
    (("\\.js\\'" . js-ts-mode)
     ("\\.ts\\'" . js-ts-mode)))
#+end_src

*** Vue
#+begin_src emacs-lisp
  ;; Vue language support
  (use-package vue-ts-mode
    :after eglot
    :hook (vue-ts-mode . eglot-ensure)
    :mode
    (("\\.vue\\'" . vue-ts-mode)))
#+end_src

*** Web Mode
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :mode
    (("\\.phtml\\'" . web-mode)
     ("\\.php\\'" . web-mode)
     ("\\.tpl\\'" . web-mode)
     ("\\.[agj]sp\\'" . web-mode)
     ("\\.as[cp]x\\'" . web-mode)
     ("\\.erb\\'" . web-mode)
     ("\\.mustache\\'" . web-mode)
     ("\\.djhtml\\'" . web-mode)))
#+end_src

*** Yaml
#+begin_src emacs-lisp
  ;; Ensure yaml-ts-mode is always enabled for YAML files
  (use-package yaml-ts-mode
    :ensure t
    :mode ("\\.yml\\'" . yaml-ts-mode)
    ("\\.yaml\\'" . yaml-ts-mode))

  ;; Use-package configuration for yaml-pro with tree-sitter support
  (use-package yaml-pro
    :ensure t
    :after treesit
    :hook ((yaml-ts-mode . yaml-pro-ts-mode)
    	 (yaml-mode . yaml-ts-mode)
    	 (before-save . yaml-pro-format-buffer))
    :config
    ;; Add keybindings for tree-sitter mode
    (define-key yaml-pro-ts-mode-map (kbd "M-RET") #'yaml-pro-ts-meta-return)
    (define-key yaml-pro-ts-mode-map (kbd "M-?") #'yaml-pro-ts-convolute-tree)
    (define-key yaml-pro-ts-mode-map (kbd "C-c @") #'yaml-pro-ts-mark-subtree)
    (define-key yaml-pro-ts-mode-map (kbd "C-c C-x C-y") #'yaml-pro-ts-paste-subtree)
    ;; Pretty formatter keybinding
    (define-key yaml-pro-ts-mode-map (kbd "C-c C-f") #'yaml-pro-format)
    ;; Easy movement with repeat map
    (keymap-set yaml-pro-ts-mode-map "C-M-n" #'yaml-pro-ts-next-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-p" #'yaml-pro-ts-prev-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-u" #'yaml-pro-ts-up-level)
    (keymap-set yaml-pro-ts-mode-map "C-M-d" #'yaml-pro-ts-down-level)
    (keymap-set yaml-pro-ts-mode-map "C-M-k" #'yaml-pro-ts-kill-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-<backspace>" #'yaml-pro-ts-kill-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-a" #'yaml-pro-ts-first-sibling)
    (keymap-set yaml-pro-ts-mode-map "C-M-e" #'yaml-pro-ts-last-sibling)
    (defvar-keymap my/yaml-pro/tree-repeat-map
      :repeat t
      "n" #'yaml-pro-ts-next-subtree
      "p" #'yaml-pro-ts-prev-subtree
      "u" #'yaml-pro-ts-up-level
      "d" #'yaml-pro-ts-down-level
      "m" #'yaml-pro-ts-mark-subtree
      "k" #'yaml-pro-ts-kill-subtree
      "a" #'yaml-pro-ts-first-sibling
      "e" #'yaml-pro-ts-last-sibling
      "SPC" #'my/yaml-pro/set-mark)
    (defun my/yaml-pro/set-mark ()
      (interactive)
      (my/region/set-mark 'my/yaml-pro/set-mark))
    (defun my/region/set-mark (command-name)
      (if (eq last-command command-name)
    	(if (region-active-p)
    	    (progn
    	      (deactivate-mark)
    	      (message "Mark deactivated"))
    	  (activate-mark)
    	  (message "Mark activated"))
        (set-mark-command nil))))

  ;; Add hook to format YAML buffer before save
  (defun yaml-pro-format-buffer ()
    "Format the current buffer with yaml-pro-format."
    (when (derived-mode-p 'yaml-ts-mode)
      (yaml-pro-format)))

  #+end_src

** LSP
Setting up eglot LSP

*** eglot
#+begin_src emacs-lisp
  (use-package eglot
    :ensure t
    :config
    (evil-leader/set-key
      "lo" 'eglot
      "lq" 'eglot-shutdown
      "la" 'eglot-code-actions
      "lf" 'apheleia-format-buffer
      "lr" 'eglot-rename
      "lR" 'eglot-reconnect
      "lH" 'eglot-inlay-hints-mode
      "ld" 'eglot-find-declaration
      "li" 'eglot-find-implementation
      "lt" 'eglot-find-typeDefinition
      "lI" 'eglot-organize-imports
      "ln" 'flymake-goto-next-error
      "lwd" 'flymake-show-project-diagnostics
      "lbd" 'flymake-show-buffer-diagnostics))
#+end_src
*** eglot-booster
#+begin_src emacs-lisp
  (use-package eglot-booster
    :after eglot
    :config
    (eglot-booster-mode))
#+end_src

** Navigation
Setting up Consult for better navigation in Emacs

#+begin_src emacs-lisp
  ;; Consulting completing-read
  (use-package consult
    :config

    (evil-leader/set-key
      "ff" 'consult-find
      "fg" 'consult-ripgrep)
    (setq consult-preview-key (list :debounce 0.1 'any)))

  (use-package consult-projectile
    :config

    (evil-leader/set-key
      "pf" 'consult-projectile-find-file
      "pw" 'consult-projectile-find-file-other-window
      "pp" 'consult-projectile-switch-project
      "TAB" 'consult-projectile-switch-to-buffer))

#+end_src

** ORG

This configuration integrates powerful Org-mode tools for both knowledge management (Org-Roam) and rich email composition (Org-msg). Together, they form a comprehensive personal information system within Emacs.
#+BEGIN_QUOTE
Org-msg transforms email composition in Emacs by leveraging Org Mode's formatting capabilities to create beautiful HTML emails while maintaining plain text alternatives.
#+END_QUOTE

**Key features:**

+ Write emails using familiar Org markup (headlines, lists, links, code blocks)
+ Automatic conversion to HTML with proper styling
+ Maintains plain text version for compatibility
+ Customized signature with formatting
+ Seamless integration with mu4e mail client

*** Org-Modern
#+begin_src emacs-lisp
  (use-package org-modern
    :ensure t
    :hook ((org-mode . org-modern-mode)
  	   (org-agenda-finalize . org-modern-agenda)))
#+end_src

*** Org-Msg
#+BEGIN_SRC emacs-lisp
  (use-package org-msg
    :ensure t
    :after mu4e
    :config
    (setq mail-user-agent 'mu4e-user-agent)
    (require 'org-msg)
    (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
  	  org-msg-startup "hidestars indent inlineimages"
  	  org-msg-default-alternatives '((new               . (text html))
  					 (reply-to-html     . (text html))
  					 (reply-to-text     . (text)))
  	  org-msg-convert-citation t)

    (defun my-org-msg-signature ()
      "Return a formatted signature for org-msg emails."
      (concat "\n\n"
              "Best regards,\n"
              "*Knut Oien*\n"
              "/Senior Software Engineer HNIKT/\n"))

    (setq org-msg-signature (my-org-msg-signature))

    (defun my-update-from-header-in-org-msg ()
      "Update the From header in org-msg buffer to use the current user-mail-address."
      (setq org-msg-signature (my-org-msg-signature))
      (save-excursion
        (goto-char (point-min))
        (when (re-search-forward "^From: .*$" nil t)
          (replace-match (format "From: %s <%s>" user-full-name user-mail-address)))))

    (add-hook 'org-msg-edit-mode-hook 'my-update-from-header-in-org-msg)
    (org-msg-mode))
#+END_SRC

*** Org-Roam
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :init
    (setq org-roam-v2-ack t)
    (setq my/daily-note-filename "%<%Y-%m-%d>.org"
  	  my/daily-note-header "#+title: %<%Y-%m-%d %a>\n\n[[roam:%<%Y-%B>]]\n\n")
    :custom
    (org-roam-directory (file-truename "~/Documents/notes"))
    (org-roam-dailies-directory "Backlog/")
    (org-roam-completion-everywhere t)
    (org-roam-capture-templates
     '(("d" "default" plain "%?"
  	:if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
  			   "#+title: ${title}\n")
  	:unnarrowed t)))
    (org-roam-dailies-capture-templates
     `(("d" "default" entry
  	"* %?"
  	:if-new (file+head ,my/daily-note-filename
  			   ,my/daily-note-header))
       ("t" "task" entry
  	"* TODO %?\n  %U\n  %a\n  %i"
  	:if-new (file+head+olp ,my/daily-note-filename
  			       ,my/daily-note-header
  			       ("Tasks"))
  	:empty-lines 1)
       ("l" "log entry" entry
  	"* %<%I:%M %p> - %?"
  	:if-new (file+head+olp ,my/daily-note-filename
  			       ,my/daily-note-header
  			       ("Log")))
       ("j" "journal" entry
  	"* %<%I:%M %p> - Journal  :journal:\n\n%?\n\n"
  	:if-new (file+head+olp ,my/daily-note-filename
  			       ,my/daily-note-header
  			       ("Log")))
       ("m" "meeting" entry
  	"* %<%I:%M %p> - %^{Meeting Title}  :meetings:\n\n%?\n\n"
  	:if-new (file+head+olp ,my/daily-note-filename
  			       ,my/daily-note-header
  			       ("Log")))))
    :bind (:map org-mode-map
  		("C-M-i" . completion-at-point))
    :config
    (org-roam-setup)
    (org-roam-db-autosync-mode))

  (define-prefix-command 'org-prefix-map)
  (global-set-key (kbd "C-x o") 'org-prefix-map)
  (define-key org-prefix-map (kbd "l") 'org-roam-buffer-toggle)
  (define-key org-prefix-map (kbd "c") 'org-roam-capture)
  (define-key org-prefix-map (kbd "f") 'org-roam-node-find)
  (define-key org-prefix-map (kbd "i") 'org-roam-node-insert)
  (define-key org-prefix-map (kbd "d") 'org-roam-dailies-capture-date)
  (define-key org-prefix-map (kbd "t") 'org-roam-dailies-goto-today)
  (define-key org-prefix-map (kbd "y") 'org-roam-dailies-goto-yesterday)
  (define-key org-prefix-map (kbd "m") 'org-roam-dailies-goto-tomorrow)
#+end_src

** Projects
Projectile is the go-to project package to use with Emacs.
- Easy to use and setup, easy use of buffers.

#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-mode +1)
    :config
    (setq projectile-enable-caching t
  	  projectile-completion-system 'ivy
  	  projectile-indexing-method 'alien
  	  projectile-sort-order 'recently-active
  	  projectile-project-search-path '(("~/Projects/" . 1)
  					   ("~/Projects/forks/" . 1)
  					   ("~/Projects/workspace/" . 1)
  					   ("~/Sources/" . 1)))

    (evil-leader/set-key
      "pc" 'projectile-cleanup-known-projects
      "pd" 'projectile-discover-projects-in-search-path))
#+end_src

** SSH

Tramp is for tranparently accessing remote files from within Emacs

#+begin_src emacs-lisp
  (use-package tramp
    :ensure t
    :config
    (add-to-list 'tramp-remote-path 'tramp-own-remote-path))
#+end_src

** Terminal
*** Detached
Setup emacs-detached

#+begin_src emacs-lisp
  (use-package detached
    :init
    (detached-init)
    :bind (([remap async-shell-command] . detached-shell-command)
  	   ([remap compile] . detached-compile)
  	   ([remap recompile] . detached-compile-recompile)
  	   ([remap detached-open-session] . detached-consult-session))
    :custom ((detached-show-output-on-attach t)
  	     (detached-terminal-data-command system-type)
  	     (detached-shell-program "bash")))

  (defun my/detached-run-command-git-root (command)
    "Run COMMAND in the project root directory using detached-shell-command."
    (interactive "sCommand: ")
    (let* ((root-dir (locate-dominating-file default-directory ".git"))
           (default-directory (or root-dir default-directory)))
      (detached-shell-command command)))

  (defun my/detached-run-command-git-root-with-path (path-and-command)
    "Run command in the project root directory using detached-shell-command.
      PATH-AND-COMMAND should be in format 'path command', e.g. 'modules/app npm run dev'.
    The first argument is treated as the relative path from git root, the rest as the command."
    (interactive "sPath and Command: ")
    (let* ((parts (split-string path-and-command " " t))
           (path (car parts))
           (command (string-join (cdr parts) " "))
           (root-dir (locate-dominating-file default-directory ".git"))
           (full-path (and root-dir (expand-file-name path root-dir)))
           (default-directory (or full-path default-directory)))
      (detached-shell-command command)))

  (evil-leader/set-key
    "da" 'detached-attach-session
    "dd" 'detached-detach-session
    "dk" 'detached-kill-session
    "dl" 'detached-list-sessions
    "do" 'detached-open-session
    "dr" 'detached-delete-session
    "dR" 'detached-delete-sessions
    "ds" 'my/detached-run-command-git-root
    "dS" 'my/detached-run-command-git-root-with-path
    "dv" 'detached-view-session
    "dc" 'detached-copy-session-command)
#+end_src

*** Vterm
Setup emacs-vterm
- Emulate a Terminal

#+begin_src emacs-lisp
  (use-package vterm
    :ensure t
    :commands vterm
    :custom
    (vterm-kill-buffer-on-exit t)
    (vterm-max-scrollback 10000)
    (vterm-clear-scrollback-when-clearing t)
    (vterm-copy-mode-remove-fake-newlines t)
    :config
    (setq vterm-buffer-name-string "vterm: %s"))

  (use-package vterm-toggle
    :ensure t
    :after vterm
    :custom
    (vterm-toggle-fullscreen-p nil)
    (vterm-toggle-scope 'project)
    :config
    (setq vterm-toggle-hide-method 'reset-window-configration))

  (defun my/vterm-in-project-root ()
    "Open vterm in the project root directory."
    (interactive)
    (let ((default-directory (or (projectile-project-root)
                                 default-directory)))
      (vterm)))

  (evil-leader/set-key
    "tt" 'vterm-toggle
    "tn" 'my/vterm-in-project-root
    "td" 'vterm
    "to" 'vterm-other-window
    "tk" (lambda () (interactive) (vterm-send-key "C-c")))

  (evil-leader/set-key
    "tc" 'vterm-toggle-cd
    "tf" 'vterm-toggle-forward
    "tb" 'vterm-toggle-backward)
#+end_src

** Version
Using magit with forge, creates the best environment for working with
Git inside Emacs, the only thing missing here is a way to approve PR.
For forge, create a file called ~/.authinfo with the following:

- machine api.github.com login gako358^forge password ==secret-token==

*** Ediff
#+begin_src emacs-lisp
  ;; Configure Ediff to use a single frame and split windows horizontally
  (setq ediff-window-setup-function #'ediff-setup-windows-plain
	ediff-split-window-function #'split-window-horizontally)
#+end_src

*** Forge
#+begin_src emacs-lisp
  (use-package forge
    :after magit
    :config
    (setq auth-sources '("~/.authinfo")))
#+end_src

*** Git-gutter
#+begin_src emacs-lisp
  (use-package git-gutter
    :hook (prog-mode . git-gutter-mode)
    :custom
    (git-gutter:update-interval 0.05))

  (use-package git-gutter-fringe
    :after git-gutter
    :config
    (fringe-mode '(8 . 8))
    (define-fringe-bitmap 'git-gutter-fr:added
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:modified
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:deleted
      [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
      nil nil 'center))
#+end_src

*** Magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (evil-leader/set-key
      "/" 'magit-status))
#+end_src

*** Vundo
#+begin_src emacs-lisp
  (use-package vundo
    :demand
    :custom
    (vundo-glyph-alist vundo-unicode-symbols))
#+end_src
