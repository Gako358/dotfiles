#+STARTUP: overview
#+TITLE: MerrinX Config
#+CREATOR: Merrinx
#+LANGUAGE: en

* Installation
Git clone https://github.com/gako358/dotfiles.git.
The configuration is setup using NixOS, check README.


* Appearance
Using the dashboard package with the kaolin-theme to enhance the startup experience and overall look of Emacs.

** Bar
The vim-tab-bar package is used for managing tabs, activated after initialization.

#+begin_src emacs-lisp
  (use-package vim-tab-bar
    :ensure t
    :commands vim-tab-bar-mode
    :hook (after-init . vim-tab-bar-mode))
#+end_src

** Dashboard
The dashboard package is configured to display a welcoming startup screen with a custom banner, recent files, bookmarks, projects, and agenda items.

#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (setq dashboard-startup-banner 'logo
          dashboard-banner-logo-title "Welcome back Master"
          dashboard-set-file-icons t
          dashboard-center-content t
          dashboard-items '((recents  . 5)
                            (bookmarks . 5)
                            (projects . 5)
                            (agenda . 5))
          initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
    :init
    :hook (after-init . dashboard-setup-startup-hook))
#+end_src

** Fonts
Custom fonts are set using "Iosevka Nerd Font" for both the main text and the mode-line, ensuring a consistent and visually appealing interface across all frames.

#+begin_src emacs-lisp
  (add-hook 'after-make-frame-functions
	    (lambda (f)
	      (with-selected-frame f
		(set-frame-font "Iosevka Nerd Font 11" nil t)
		(set-face-attribute 'mode-line nil :font "Iosevka Nerd Font 12" :height 100))))

  (add-to-list 'default-frame-alist '(height . 64))
  (add-to-list 'default-frame-alist '(width . 370))
#+end_src

** Icons

All-the-icons: Provides a rich set of icons for various file types and modes.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+end_src

All-the-icons-ivy-rich: Enhances Ivy's minibuffer completion with icons, activated on startup.

#+begin_src emacs-lisp
  (use-package all-the-icons-ivy-rich
    :ensure t
    :init (all-the-icons-ivy-rich-mode 1))
#+end_src

Nerd-icons: Sets "Iosevka Nerd Font" as the icon font family.
Nerd-icons-completion: Integrates with Marginalia for enhanced completion visuals.
Nerd-icons-corfu: Adds pretty icons to Corfu completion menus.

#+begin_src emacs-lisp
  (use-package nerd-icons
    :ensure t
    :config
    (setq nerd-icons-font-family "Iosevka Nerd Font"))

  ;; Pretty icons for completion
  (use-package nerd-icons-completion
    :ensure t
    :after marginalia
    :config
    (nerd-icons-completion-marginalia-setup)
    (nerd-icons-completion-mode 1))

  (use-package nerd-icons-corfu
    :ensure t
    :after corfu
    :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

#+end_src

** Themes
The kaolin-themes package is used with specific settings for a personalized look, loading the "kaolin-ocean" theme.

#+begin_src emacs-lisp
  (use-package kaolin-themes
    :config
    (setq kaolin-ocean-alt-bg t)
    (setq kaolin-themes-italic-comments t
          kaolin-themes-hl-line-colored t
          kaolin-themes-git-gutter-solid t)
    (load-theme 'kaolin-ocean t))
#+end_src

* Completion
Using Corfu, vertico and cape for code completion.

#+begin_src emacs-lisp
  ;; Enable indentation and completion with the TAB key.
  (setq tab-always-indent 'complete)

  ;; Cycle with the TAB key if there are only few candidates.
  (setq completion-cycle-threshold 3)
#+end_src

** Cape
Completion At Point Extensions:
- Cape: Provides extensions for completion-at-point-functions to enhance the completion experience for files and Emacs Lisp blocks.

#+begin_src emacs-lisp
  ;; Completion At Point Extensions.
  (use-package cape
    :ensure t
    :init
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block)
    )
#+end_src

** Copilot
AI-Powered Code Completion:
- Copilot: Integrates GitHub Copilot for AI-powered code completion, with custom keybindings and configuration for different modes.

#+begin_src emacs-lisp
  (use-package dash :ensure t)
  (use-package s :ensure t)
  (use-package editorconfig
    :ensure t
    :config
    (editorconfig-mode 1))
  (use-package f :ensure t)
  (use-package copilot
    :ensure t
    :bind (:map copilot-completion-map
		("C-e" . copilot-accept-completion)
		("C-S-e" . copilot-accept-completion-by-word))
    :config
    (defun toggle-copilot-mode ()
      "Toggle Copilot mode on and off."
      (interactive)
      (if (bound-and-true-p copilot-mode)
	  (copilot-mode -1)
	(copilot-mode 1)))

    (global-set-key (kbd "C-c C-p") 'toggle-copilot-mode)

    (add-to-list 'copilot-indentation-alist '(prog-mode . 2))
    (add-to-list 'copilot-indentation-alist '(org-mode . 2))
    (add-to-list 'copilot-indentation-alist '(text-mode . 2))
    (add-to-list 'copilot-indentation-alist '(closure-mode . 2))
    (add-to-list 'copilot-indentation-alist '(nix-ts-mode . 2))
    (add-to-list 'copilot-indentation-alist '(nix-mode . 2))
    (add-to-list 'copilot-indentation-alist '(scala-ts-mode . 2))
    (add-to-list 'copilot-indentation-alist '(scala-mode . 2))
    (add-to-list 'copilot-indentation-alist '(java-ts-mode . 2))
    (add-to-list 'copilot-indentation-alist '(java-mode . 2))
    (add-to-list 'copilot-indentation-alist '(emacs-lisp-mode . 2)))
#+end_src

** Corfu
Completion Overlay Region Function:
- Corfu: Provides a completion overlay for better in-line completion, with custom keybindings for navigation and configuration for an improved user experience.

#+begin_src emacs-lisp
  ;; Completion Overlay Region Function.
  (use-package corfu
    :init
    (global-corfu-mode 1)
    (setq global-corfu-minibuffer
  	(lambda ()
  	  (not (or (bound-and-true-p mct--active)
  		   (bound-and-true-p vertico--input)
  		   (eq (current-local-map) read-passwd-map)))))
    :bind (:map corfu-map
  	      ("C-n" . corfu-next)
  	      ("C-p" . corfu-previous)
  	      ("C-h" . corfu-info-documentation)
  	      )

    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-preview-current nil)
    (corfu-quit-at-boundary t)
    (corfu-quit-no-match t)

    :config
    ;; Add Evil-specific binding for C-y in Corfu
    (with-eval-after-load 'evil
      (define-key evil-insert-state-map (kbd "C-y")
                  (lambda ()
                    (interactive)
                    (if (and (boundp 'corfu-mode) corfu-mode)
                        (corfu-insert)
                      (evil-paste-before 1)))))


    )
#+end_src

** Embark
Context Menu for Actions:
- Embark: Offers a context menu for performing actions on selected items directly from the completion interface.

#+begin_src emacs-lisp
  (use-package embark
    ;; Embark is an Emacs package that acts like a context menu, allowing
    ;; users to perform context-sensitive actions on selected items
    ;; directly from the completion interface.
    :ensure t
    :defer t
    :commands (embark-act
  	     embark-dwim
  	     embark-export
  	     embark-collect
  	     embark-bindings
  	     embark-prefix-help-command)
    :init
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))
#+end_src

** Eldoc
#+begin_src emacs-lisp
  (use-package eldoc-box
    :ensure t
    :config
    (evil-leader/set-key
      "lh" 'eldoc-box-help-at-point))
#+end_src

** Marginalia
Annotations for Completion Candidates:
- Marginalia: Adds rich annotations to completion candidates, enhancing the completion experience with additional context.

#+begin_src emacs-lisp
  ;; Annotations for completion candidates.
  (use-package marginalia
    ;; Marginalia allows Embark to offer you preconfigured actions in more contexts.
    ;; In addition to that, Marginalia also enhances Vertico by adding rich
    ;; annotations to the completion candidates displayed in Vertico's interface.
    :ensure t
    :defer t
    :commands (marginalia-mode marginalia-cycle)
    :hook (after-init . marginalia-mode))
#+end_src

** Orderless
Flexible Matching:
- Orderless: Provides flexible matching capabilities for completion, allowing multiple patterns to be matched in any order.

#+begin_src emacs-lisp
  ;; Space-separated matching components matching in any order.
  (use-package orderless
    ;; Vertico leverages Orderless' flexible matching capabilities, allowing users
    ;; to input multiple patterns separated by spaces, which Orderless then
    ;; matches in any order against the candidates.
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Vertico
Vertical Interactive Completion UI:
- Vertico: Offers a vertical completion interface, improving the user experience for navigating and selecting completion candidates.

#+begin_src emacs-lisp
  ;; Vertical interactive completion UI.
  ;; Tip: You can remove the `vertico-mode' use-package and replace it
  ;;      with the built-in `fido-vertical-mode'.
  (use-package vertico
    ;; (Note: It is recommended to also enable the savehist package.)
    :ensure t
    :defer t
    :commands vertico-mode
    :hook (after-init . vertico-mode))
#+end_src

** Grep
Writable Grep:
- wgrep: Allows editing of grep buffers, enabling changes to be applied directly to files.

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src

** Yasnippet
Snippet Expansion:
- Yasnippet: Provides support for snippet expansion, allowing predefined templates to be used for faster coding.
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :init
    (yas-global-mode 1))
#+end_src

* Core
#+begin_src emacs-lisp
  (defvar minimal-emacs-ui-features '()
    "List of user interface features to disable in minimal Emacs setup.

  This variable holds a list Emacs UI features that can be enabled:
  - `context-menu`: Enables the context menu in graphical environments.
  - `tool-bar`: Enables the tool bar in graphical environments.
  - `menu-bar`: Enables the menu bar in graphical environments.
  - `dialogs`: Enables both file dialogs and dialog boxes.
  - `tooltips`: Enables tooltips.

  Each feature in the list corresponds to a specific UI component that can be
  turned on.")

  (defvar minimal-emacs-frame-title-format "%b â€“ Emacs"
    "Template for displaying the title bar of visible and iconified frame.")

  (defvar minimal-emacs-debug nil
    "Non-nil to enable debug.")

  (defvar minimal-emacs-gc-cons-threshold (* 16 1024 1024)
    "The value of `gc-cons-threshold' after Emacs startup.")

  (defvar minimal-emacs-package-initialize-and-refresh t
    "Whether to automatically initialize and refresh packages.
  When set to non-nil, Emacs will automatically call `package-initialize' and
  `package-refresh-contents' to set up and update the package system.")

  (defvar minimal-emacs-user-directory user-emacs-directory
    "The default value of the `user-emacs-directory' variable.")

  ;;; Load pre-early-init.el

  (defun minimal-emacs-load-user-init (filename)
    "Execute a file of Lisp code named FILENAME."
    (let ((user-init-file
           (expand-file-name filename
                             minimal-emacs-user-directory)))
      (when (file-exists-p user-init-file)
        (load user-init-file nil t))))

  (minimal-emacs-load-user-init "pre-early-init.el")

  (setq custom-theme-directory
        (expand-file-name "themes/" minimal-emacs-user-directory))
  (setq custom-file (expand-file-name "custom.el" minimal-emacs-user-directory))

  ;;; Garbage collection
  ;; Garbage collection significantly affects startup times. This setting delays
  ;; garbage collection during startup but will be reset later.

  (setq gc-cons-threshold most-positive-fixnum)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold minimal-emacs-gc-cons-threshold)))

  ;;; Misc

  (set-language-environment "UTF-8")

  ;; Set-language-environment sets default-input-method, which is unwanted.
  (setq default-input-method nil)

  ;;; Performance

  ;; Prefer loading newer compiled files
  (setq load-prefer-newer t)

  ;; Font compacting can be very resource-intensive, especially when rendering
  ;; icon fonts on Windows. This will increase memory usage.
  (setq inhibit-compacting-font-caches t)

  (unless (daemonp)
    (let ((old-value (default-toplevel-value 'file-name-handler-alist)))
      (set-default-toplevel-value
       'file-name-handler-alist
       ;; Determine the state of bundled libraries using calc-loaddefs.el.
       ;; If compressed, retain the gzip handler in `file-name-handler-alist`.
       ;; If compiled or neither, omit the gzip handler during startup for
       ;; improved startup and package load time.
       (if (eval-when-compile
             (locate-file-internal "calc-loaddefs.el" load-path))
           nil
         (list (rassq 'jka-compr-handler old-value))))
      ;; Ensure the new value persists through any current let-binding.
      (set-default-toplevel-value 'file-name-handler-alist
                                  file-name-handler-alist)
      ;; Remember the old value to reset it as needed.
      (add-hook 'emacs-startup-hook
                (lambda ()
                  (set-default-toplevel-value
                   'file-name-handler-alist
                   ;; Merge instead of overwrite to preserve any changes made
                   ;; since startup.
                   (delete-dups (append file-name-handler-alist old-value))))
                101))

    (unless noninteractive
      (unless minimal-emacs-debug
        (unless minimal-emacs-debug
          ;; Suppress redisplay and redraw during startup to avoid delays and
          ;; prevent flashing an unstyled Emacs frame.
          ;; (setq-default inhibit-redisplay t) ; Can cause artifacts
          (setq-default inhibit-message t)

          ;; Reset the above variables to prevent Emacs from appearing frozen or
          ;; visually corrupted after startup or if a startup error occurs.
          (defun minimal-emacs--reset-inhibited-vars-h ()
            ;; (setq-default inhibit-redisplay nil) ; Can cause artifacts
            (setq-default inhibit-message nil)
            (remove-hook 'post-command-hook #'minimal-emacs--reset-inhibited-vars-h))

          (add-hook 'post-command-hook
                    #'minimal-emacs--reset-inhibited-vars-h -100))

        (dolist (buf (buffer-list))
          (with-current-buffer buf
            (setq mode-line-format nil)))

        (put 'mode-line-format 'initial-value
             (default-toplevel-value 'mode-line-format))
        (setq-default mode-line-format nil)

        (defun minimal-emacs--startup-load-user-init-file (fn &rest args)
          "Advice for startup--load-user-init-file to reset mode-line-format."
          (unwind-protect
              (progn
                ;; Start up as normal
                (apply fn args))
            ;; If we don't undo inhibit-{message, redisplay} and there's an
            ;; error, we'll see nothing but a blank Emacs frame.
            (setq-default inhibit-message nil)
            (unless (default-toplevel-value 'mode-line-format)
              (setq-default mode-line-format
                            (get 'mode-line-format 'initial-value)))))

        (advice-add 'startup--load-user-init-file :around
                    #'minimal-emacs--startup-load-user-init-file))

      ;; Without this, Emacs will try to resize itself to a specific column size
      (setq frame-inhibit-implied-resize t)

      ;; A second, case-insensitive pass over `auto-mode-alist' is time wasted.
      ;; No second pass of case-insensitive search over auto-mode-alist.
      (setq auto-mode-case-fold nil)

      ;; Reduce *Message* noise at startup. An empty scratch buffer (or the
      ;; dashboard) is more than enough, and faster to display.
      (setq inhibit-startup-screen t
            inhibit-startup-echo-area-message user-login-name)
      (setq initial-buffer-choice nil
            inhibit-startup-buffer-menu t
            inhibit-x-resources t)

      ;; Disable bidirectional text scanning for a modest performance boost.
      (setq-default bidi-display-reordering 'left-to-right
                    bidi-paragraph-direction 'left-to-right)

      ;; Give up some bidirectional functionality for slightly faster re-display.
      (setq bidi-inhibit-bpa t)

      ;; Remove "For information about GNU Emacs..." message at startup
      (advice-add #'display-startup-echo-area-message :override #'ignore)

      ;; Suppress the vanilla startup screen completely. We've disabled it with
      ;; `inhibit-startup-screen', but it would still initialize anyway.
      (advice-add #'display-startup-screen :override #'ignore)

      ;; Shave seconds off startup time by starting the scratch buffer in
      ;; `fundamental-mode'
      (setq initial-major-mode 'fundamental-mode
            initial-scratch-message nil)

      (unless minimal-emacs-debug
        ;; Unset command line options irrelevant to the current OS. These options
        ;; are still processed by `command-line-1` but have no effect.
        (unless (eq system-type 'darwin)
          (setq command-line-ns-option-alist nil))
        (unless (memq initial-window-system '(x pgtk))
          (setq command-line-x-option-alist nil)))))

  ;;; Native compilation and Byte compilation

  (if (and (featurep 'native-compile)
           (fboundp 'native-comp-available-p)
           (native-comp-available-p))
      ;; Activate `native-compile'
      (setq native-comp-jit-compilation t
            native-comp-deferred-compilation t  ; Obsolete since Emacs 29.1
            package-native-compile t)
    ;; Deactivate the `native-compile' feature if it is not available
    (setq features (delq 'native-compile features)))

  ;; Suppress compiler warnings and don't inundate users with their popups.
  (setq native-comp-async-report-warnings-errors
        (or minimal-emacs-debug 'silent))
  (setq native-comp-warning-on-missing-source minimal-emacs-debug)

  (setq debug-on-error minimal-emacs-debug
        jka-compr-verbose minimal-emacs-debug)

  (setq byte-compile-warnings minimal-emacs-debug)
  (setq byte-compile-verbose minimal-emacs-debug)

  ;;; UI elements

  (setq frame-title-format minimal-emacs-frame-title-format
        icon-title-format minimal-emacs-frame-title-format)

  ;; Disable startup screens and messages
  (setq inhibit-splash-screen t)

  ;; I intentionally avoid calling `menu-bar-mode', `tool-bar-mode', and
  ;; `scroll-bar-mode' because manipulating frame parameters can trigger or queue
  ;; a superfluous and potentially expensive frame redraw at startup, depending
  ;; on the window system. The variables must also be set to `nil' so users don't
  ;; have to call the functions twice to re-enable them.
  (unless (memq 'menu-bar minimal-emacs-ui-features)
    (push '(menu-bar-lines . 0) default-frame-alist)
    (unless (memq window-system '(mac ns))
      (setq menu-bar-mode nil)))

  (unless (daemonp)
    (unless noninteractive
      (when (fboundp 'tool-bar-setup)
        ;; Temporarily override the tool-bar-setup function to prevent it from
        ;; running during the initial stages of startup
        (advice-add #'tool-bar-setup :override #'ignore)
        (define-advice startup--load-user-init-file
            (:after (&rest _) minimal-emacs-setup-toolbar)
          (advice-remove #'tool-bar-setup #'ignore)
          (when tool-bar-mode
            (tool-bar-setup))))))
  (unless (memq 'tool-bar minimal-emacs-ui-features)
    (push '(tool-bar-lines . 0) default-frame-alist)
    (setq tool-bar-mode nil))

  (push '(vertical-scroll-bars) default-frame-alist)
  (push '(horizontal-scroll-bars) default-frame-alist)
  (setq scroll-bar-mode nil)
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))

  (unless (memq 'tooltips minimal-emacs-ui-features)
    (when (bound-and-true-p tooltip-mode)
      (tooltip-mode -1)))

  ;; Disable GUIs because they are inconsistent across systems, desktop
  ;; environments, and themes, and they don't match the look of Emacs.
  (unless (memq 'dialogs minimal-emacs-ui-features)
    (setq use-file-dialog nil)
    (setq use-dialog-box nil))

  ;;; LSP
  (setenv "LSP_USE_PLISTS" "true")

  ;; Disable sound bell
  (setq visible-bell 1)

#+end_src

* Edit
Edit, format, and grammar support for various programming languages and markdown.

** Apheleia
Formatters:
- Apheleia: Provides on-the-fly code formatting using various formatters:
  -  Scalafmt for Scala
  -  Black for Python
  -  Prettier for TypeScript and JavaScript
  -  Google Java Format for Java
  -  nixpkgs-fmt for Nix

#+begin_src emacs-lisp
  ;; Formatters
  (use-package apheleia
    :config
    ;; Add scalafmt for Scala
    (push '(scalafmt . ("scalafmt" "--stdin" "--non-interactive" "--quiet" "--stdout")) apheleia-formatters)
    (push '(scala-ts-mode . scalafmt) apheleia-mode-alist)

    ;; Add black for Python
    (push '(black . ("black" "-")) apheleia-formatters)
    (push '(python-mode . black) apheleia-mode-alist)

    ;; Add prettier for TypeScript and JavaScript
    (push '(prettier . ("prettier" "--stdin-filepath" buffer-file-name)) apheleia-formatters)
    (push '(typescript-ts-mode . prettier) apheleia-mode-alist)
    (push '(js-ts-mode . prettier) apheleia-mode-alist)

    ;; Add google-java-format for Java
    (push '(google-java-format . ("google-java-format" "-")) apheleia-formatters)
    (push '(java-ts-mode . google-java-format) apheleia-mode-alist)

    ;; Add nixpkgs-fmt for Nix
    (push '(nixpkgs-fmt . ("nixpkgs-fmt")) apheleia-formatters)
    (push '(nix-mode . nixpkgs-fmt) apheleia-mode-alist))

  (apheleia-global-mode +1)
#+end_src

* Filetree
Config dirvish

#+begin_src emacs-lisp
  (use-package dirvish
   :ensure t
   :init
   (dirvish-override-dired-mode)
   :custom
   (dirvish-quick-access-entries ; it's a custom option, `setq' won't work
    '(("h" "~/"                          "home")
      ("d" "~/downloads/"                "downloads")
      ("m" "/mnt/"                       "drives")
      ("p" "~/src/"                      "projects")
      ("t" "~/.local/share/trash/files/" "trashcan")))
   :config
   ;; (dirvish-peek-mode)             ; preview files in minibuffer
   ;; (dirvish-side-follow-mode)      ; similar to `treemacs-follow-mode'
   (setq dirvish-mode-line-format
         '(:left (sort symlink) :right (omit yank index)))
   (setq dirvish-attributes           ; the order *matters* for some attributes
         '(vc-state subtree-state nerd-icons collapse git-msg file-time file-size)
         dirvish-side-attributes
         '(vc-state nerd-icons collapse file-size))
   (setq delete-by-moving-to-trash t)
   (setq dired-listing-switches
         "-l --almost-all --human-readable --group-directories-first --no-group")
   :bind
   (:map dirvish-mode-map
         ("m-a" . dirvish-quick-access)
         ("m-f" . dirvish-file-info-menu)
         ("m-y" . dirvish-yank-menu)
         ("m-h" . dired-up-directory)
         ("m-n" . dired-create-empty-file)
         ("m-v" . dirvish-vc-menu)      ; remapped `dired-view-file'
         ("m-o" . dirvish-subtree-toggle)
         ("m-l" . dirvish-ls-switches-menu)
         ("m-m" . dirvish-mark-menu)
         ("m-t" . dirvish-layout-toggle)
         ("m-s" . dirvish-setup-menu)
         ("m-e" . dirvish-emerge-menu)
         ("m-q" . dirvish-quit)
         ("m-j" . dirvish-fd-jump))
   (add-hook 'dirvish-setup-hook (lambda ()
                                   (visual-line-mode -1)
                                   (setq-local truncate-lines t)))
   (evil-leader/set-key
     "rf" 'dirvish))
#+end_src

* General
#+begin_src emacs-lisp
  ;; Ensure Emacs loads the most recent byte-compiled files.
  (setq load-prefer-newer t)

  ;; Ensure JIT compilation is enabled for improved performance by
  ;; native-compiling loaded .elc files asynchronously
  (setq native-comp-jit-compilation t)
                                          ;(setq native-comp-deferred-compilation t) ; Deprecated in Emacs > 29.1

                                          ;(use-package compile-angel
                                          ;  :ensure t
                                          ;  :demand t
                                          ;  :config
                                          ;  (compile-angel-on-load-mode)
                                          ;  (add-hook 'emacs-lisp-mode-hook #'compile-angel-on-save-local-mode))

  ;; Auto-revert in Emacs is a feature that automatically updates the
  ;; contents of a buffer to reflect changes made to the underlying file
  ;; on disk.
  (add-hook 'after-init-hook #'global-auto-revert-mode)

  ;; recentf is an Emacs package that maintains a list of recently
  ;; accessed files, making it easier to reopen files you have worked on
  ;; recently.
  (add-hook 'after-init-hook #'recentf-mode)

  ;; savehist is an Emacs feature that preserves the minibuffer history between
  ;; sessions. It saves the history of inputs in the minibuffer, such as commands,
  ;; search strings, and other prompts, to a file. This allows users to retain
  ;; their minibuffer history across Emacs restarts.
  (add-hook 'after-init-hook #'savehist-mode)

  ;; save-place-mode enables Emacs to remember the last location within a file
  ;; upon reopening. This feature is particularly beneficial for resuming work at
  ;; the precise point where you previously left off.
  (add-hook 'after-init-hook #'save-place-mode)

  ;; Turn on which-key-mode
  (add-hook 'after-init-hook 'which-key-mode)

  ;; Turn off autosave-mode
  ;; turn off backup-files
  (auto-save-mode -1)
  (setq make-backup-files nil)
  (setq auto-save-default nil)

  ;;; Line numbers
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode)

  ;;; Direnv integration
  (use-package envrc
    :hook (after-init . envrc-global-mode))

  (use-package undo-fu-session
    :ensure t
    :config
    (undo-fu-session-global-mode))
#+end_src
* Grammars
Setting up treesitter grammars
#+begin_src emacs-lisp
  (use-package treesit
    :ensure nil
    :custom
    (treesit-font-lock-level 4) ;; Set font lock level for Tree-sitter
    :config
    (seq-do (lambda (it)
	      (push it major-mode-remap-alist))
	    '((css-mode . css-ts-mode) ;; Remap CSS mode to Tree-sitter mode
	      (c-mode . c-ts-mode) ;; Remap C mode to Tree-sitter mode
	      (dockerfile-mode . dockerfile-ts-mode) ;; Remap Dockerfile mode to Tree-sitter mode
	      (haskell-mode . haskell-ts-mode) ;; Remap Haskell mode to Tree-sitter mode
	      (java-mode . java-ts-mode) ;; Remap Java mode to Tree-sitter mode
	      (javascript-mode . js-ts-mode) ;; Remap JavaScript mode to Tree-sitter mode
	      (python-mode . python-ts-mode) ;; Remap Python mode to Tree-sitter mode
	      (scala-mode . scala-ts-mode) ;; Remap Scala mode to Tree-sitter mode
	      (sh-mode . bash-ts-mode) ;; Remap Shell Script mode to Tree-sitter mode
	      (shell-script-mode . bash-ts-mode) ;; Remap Shell Script mode to Tree-sitter mode
	      (typescript-mode . typescript-ts-mode) ;; Remap TypeScript mode to Tree-sitter mode
	      (yaml-mode . yaml-ts-mode)))) ;; Remap YAML mode to Tree-sitter mode
#+end_src

* Keybindings
Keys that I have binded to my keyboard for easy navigation in emacs

** Evil Mode
#+begin_src emacs-lisp
  ;; evil-want-keybinding must be declared before Evil and Evil Collection
  (setq evil-want-keybinding nil)

  (use-package evil
    :ensure t
    :init
    (setq evil-undo-system 'undo-fu)
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    :custom
    (evil-want-Y-yank-to-eol t)
    :config
    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-mode 1))

  ;; Define scroll up
  (define-key evil-normal-state-map (kbd "C-u") 'evil-scroll-up)
  (define-key evil-visual-state-map (kbd "C-u") 'evil-scroll-up)
  (define-key evil-insert-state-map (kbd "C-u")
      	    (lambda ()
      	      (interactive)
      	      (evil-delete (point-at-bol) (point))))

  ;; Evil numbers inc and dec
  (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-visual-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-x") 'evil-numbers/dec-at-pt)
  (define-key evil-visual-state-map (kbd "C-x") 'evil-numbers/dec-at-pt)
  ;; Redefine keys for switching windows
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
#+end_src

** Evil Leader
#+begin_src emacs-lisp
  (use-package evil-leader
    :ensure t
    :config
    (global-evil-leader-mode)
    (evil-leader/set-leader "<SPC>"))
#+end_src

** Evil Collection
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :ensure t
    :hook (evil-mode . evil-collection-init)
    :bind (([remap evil-show-marks] . evil-collection-consult-mark)
           ([remap evil-show-jumps] . evil-collection-consult-jump-list))
    :config
    ;; Make `evil-collection-consult-mark' and `evil-collection-consult-jump-list'
    ;; immediately available.
    (evil-collection-require 'consult)
    :custom
    (evil-collection-setup-debugger-keys nil)
    (evil-collection-calendar-want-org-bindings t)
    (evil-collection-unimpaired-want-repeat-mode-integration t))
#+end_src

** Evil Visual Star
#+begin_src emacs-lisp
  (use-package evil-visualstar
    :after evil
    :ensure t
    :defer t
    :commands global-evil-visualstar-mode
    :hook (after-init . global-evil-visualstar-mode))
#+end_src

** Evil Surround
#+begin_src emacs-lisp
  (use-package evil-surround
    :after evil
    :ensure t
    :defer t
    :commands global-evil-surround-mode
    :custom
    (evil-surround-pairs-alist
     '((?\( . ("(" . ")"))
       (?\[ . ("[" . "]"))
       (?\{ . ("{" . "}"))

       (?\) . ("(" . ")"))
       (?\] . ("[" . "]"))
       (?\} . ("{" . "}"))

       (?< . ("<" . ">"))
       (?> . ("<" . ">"))))
    :hook (after-init . global-evil-surround-mode))
#+end_src

** Evil Keybindings
#+begin_src emacs-lisp
  (with-eval-after-load "evil"
    (evil-define-operator my-evil-comment-or-uncomment (beg end)
      "Toggle comment for the region between BEG and END."
      (interactive "<r>")
      (comment-or-uncomment-region beg end))
    (evil-define-key 'normal 'global (kbd "gc") 'my-evil-comment-or-uncomment))

  (defun move-right-and-open-todo ()
    (interactive)
    (split-window-right)
    (windmove-right)
    (find-file "~/Documents/notes/org/todo.org"))

  (defun replace-word-at-point ()
    "Replace all occurrences of the word at point with a user-provided word in the current buffer."
    (let ((old-word (thing-at-point 'word))
          (new-word (read-string "Enter new word: ")))
      (save-excursion
        (goto-char (point-min))
        (while (search-forward old-word nil t)
          (replace-match new-word)))))

  (global-set-key (kbd "C-S-i") 'move-right-and-open-todo)

  (defun move-text-internal (arg)
    (cond
     ((and mark-active transient-mark-mode)
      (if (> (point) (mark))
          (exchange-point-and-mark))
      (let ((column (current-column))
            (text (delete-and-extract-region (point) (mark))))
        (forward-line arg)
        (move-to-column column t)
        (set-mark (point))
        (insert text)
        (exchange-point-and-mark)
        (setq deactivate-mark nil)))
     (t
      (beginning-of-line)
      (when (or (> arg 0) (not (bobp)))
        (forward-line)
        (when (or (< arg 0) (not (eobp)))
          (transpose-lines arg))
        (forward-line -1)))))

  (defun move-text-down (arg)
    (interactive "*p")
    (move-text-internal arg))

  (defun move-text-up (arg)
    (interactive "*p")
    (move-text-internal (- arg)))

  (global-set-key (kbd "S-<up>") 'move-text-up)
  (global-set-key (kbd "S-<down>") 'move-text-down)
  (global-set-key (kbd "C-S-<right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "C-S-<left>") 'shrink-window-horizontally)
  (global-set-key (kbd "C-S-<down>") 'shrink-window)
  (global-set-key (kbd "C-S-<up>") 'enlarge-window)
  (global-set-key (kbd "C-<tab>") 'evil-switch-to-windows-last-buffer)
#+end_src

* Languages
Using Eglot, Emacs built-in LSP client.
Setup using:
- C
- Dockerfile
- Haskell
- Java
- Markdown
- Nix
- Rust
- SBT and Scala
- SQL
- Typescript
- Yaml

Using own created web mode, for Vue, TypeScript, and Tailwind.

** C
#+begin_src emacs-lisp
  ;; C language server
  (use-package c-ts-mode
    :hook (c-ts-mode . eglot-ensure)
    :mode (("\\.c\\'" . c-ts-mode)
	   ("\\.h\\'" . c-ts-mode)))
    #+end_src

** Dockerfile

#+begin_src emacs-lisp
  (use-package dockerfile-ts-mode)
#+end_src

** Haskell
#+begin_src emacs-lisp
  (use-package haskell-ts-mode
    :mode (("\\.hs\\'" . haskell-ts-mode)
	   ("\\.cabal\\'" . haskell-ts-mode)))
#+end_src

** Java
#+begin_src emacs-lisp
  ;; Java language server
  (use-package eglot-java
    :init
    :hook (java-ts-mode . eglot-java-mode))

  (with-eval-after-load 'eglot-java
    (evil-leader/set-key
      "ljn" 'eglot-java-file-new
      "ljx" 'eglot-java-run-main
      "ljt" 'eglot-java-run-test
      "ljN" 'eglot-java-project-new
      "ljT" 'eglot-java-project-build-task
      "ljR" 'eglot-java-project-build-refresh))

#+end_src

** Markdown
Markdown Edit:
- Markdown Mode: Provides support for editing markdown files, enhancing the writing and formatting experience.

#+begin_src emacs-lisp
  ;; Markdown edit
  (use-package markdown-mode)
#+end_src

** Nix
#+begin_src emacs-lisp
  (use-package nix-ts-mode
    :mode "\\.nix\\'"
    :hook ((nix-ts-mode . eglot-ensure)
  	 (before-save . eglot-format-buffer)
  	 (before-save . nixpkgs-fmt-before-save)))

  (defun nixpkgs-fmt-before-save ()
    "Format the current buffer with nixpkgs-fmt if it is available."
    (when (eq major-mode 'nix-ts-mode)
      (if (executable-find "nixpkgs-fmt")
	  (let ((output-buffer (get-buffer-create "*nixpkgs-fmt*")))
	    (shell-command-on-region (point-min) (point-max) "nixpkgs-fmt" output-buffer t)
	    (kill-buffer output-buffer))
	(message "nixpkgs-fmt not found in PATH, skipping formatting."))))

  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(nix-ts-mode . ("nil" "--stdio"))))
#+end_src

** Rust
#+begin_src emacs-lisp
  ;; Rust language server
  (use-package rust-ts-mode
    :mode "\\.rs\\'"
    :hook
    (rust-ts-mode-hook . eglot-ensure)
    :init
    (with-eval-after-load 'org
      (cl-pushnew '("rust" . rust-ts-mode) org-src-lang-modes :test #'equal)))
#+end_src

** Scala
#+begin_src emacs-lisp
  ;; Scala language server
  (use-package scala-ts-mode
    :init
    (setq scala-ts-indent-offset 2)
    :hook ((scala-ts-mode . eglot-ensure)
	   (before-save . eglot-format-buffer)))

  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(scala-ts-mode . ("metals"))))
#+end_src

** SQL
#+begin_src emacs-lisp
  ;; SQL syntax-based indentation
  (use-package sql-indent
    :ensure t
    :hook (sql-mode . sqlind-minor-mode))

  (with-eval-after-load 'sql-indent
    (add-hook 'sql-mode-hook 'sqlind-minor-mode))
#+end_src

** TypeScript
#+begin_src emacs-lisp
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flymake-mode +1)
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1))

  ;; formats the buffer before saving
  (add-hook 'before-save-hook 'tide-format-before-save)
  (add-hook 'typescript-ts-mode-hook #'setup-tide-mode)

  ;; for js-ts-mode with eglot
  (use-package js-ts-mode
    :after eglot
    :hook (js-ts-mode . eglot-ensure)
    :mode
    (("\\.js\\'" . js-ts-mode)
     ("\\.ts\\'" . js-ts-mode)))
#+end_src

** Vue
#+begin_src emacs-lisp
  ;; Vue language support
  (use-package vue-ts-mode
    :after eglot
    :hook (vue-ts-mode . eglot-ensure)
    :mode
    (("\\.vue\\'" . vue-ts-mode)))
#+end_src

** Web Mode
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :mode
    (("\\.phtml\\'" . web-mode)
     ("\\.php\\'" . web-mode)
     ("\\.tpl\\'" . web-mode)
     ("\\.[agj]sp\\'" . web-mode)
     ("\\.as[cp]x\\'" . web-mode)
     ("\\.erb\\'" . web-mode)
     ("\\.mustache\\'" . web-mode)
     ("\\.djhtml\\'" . web-mode)))
#+end_src

** Yaml
#+begin_src emacs-lisp
  ;; Ensure yaml-ts-mode is always enabled for YAML files
  (use-package yaml-ts-mode
    :ensure t
    :mode ("\\.yml\\'" . yaml-ts-mode)
    ("\\.yaml\\'" . yaml-ts-mode))

  ;; Use-package configuration for yaml-pro with tree-sitter support
  (use-package yaml-pro
    :ensure t
    :after treesit
    :hook ((yaml-ts-mode . yaml-pro-ts-mode)
    	 (yaml-mode . yaml-ts-mode)
    	 (before-save . yaml-pro-format-buffer))
    :config
    ;; Add keybindings for tree-sitter mode
    (define-key yaml-pro-ts-mode-map (kbd "M-RET") #'yaml-pro-ts-meta-return)
    (define-key yaml-pro-ts-mode-map (kbd "M-?") #'yaml-pro-ts-convolute-tree)
    (define-key yaml-pro-ts-mode-map (kbd "C-c @") #'yaml-pro-ts-mark-subtree)
    (define-key yaml-pro-ts-mode-map (kbd "C-c C-x C-y") #'yaml-pro-ts-paste-subtree)
    ;; Pretty formatter keybinding
    (define-key yaml-pro-ts-mode-map (kbd "C-c C-f") #'yaml-pro-format)
    ;; Easy movement with repeat map
    (keymap-set yaml-pro-ts-mode-map "C-M-n" #'yaml-pro-ts-next-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-p" #'yaml-pro-ts-prev-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-u" #'yaml-pro-ts-up-level)
    (keymap-set yaml-pro-ts-mode-map "C-M-d" #'yaml-pro-ts-down-level)
    (keymap-set yaml-pro-ts-mode-map "C-M-k" #'yaml-pro-ts-kill-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-<backspace>" #'yaml-pro-ts-kill-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-a" #'yaml-pro-ts-first-sibling)
    (keymap-set yaml-pro-ts-mode-map "C-M-e" #'yaml-pro-ts-last-sibling)
    (defvar-keymap my/yaml-pro/tree-repeat-map
      :repeat t
      "n" #'yaml-pro-ts-next-subtree
      "p" #'yaml-pro-ts-prev-subtree
      "u" #'yaml-pro-ts-up-level
      "d" #'yaml-pro-ts-down-level
      "m" #'yaml-pro-ts-mark-subtree
      "k" #'yaml-pro-ts-kill-subtree
      "a" #'yaml-pro-ts-first-sibling
      "e" #'yaml-pro-ts-last-sibling
      "SPC" #'my/yaml-pro/set-mark)
    (defun my/yaml-pro/set-mark ()
      (interactive)
      (my/region/set-mark 'my/yaml-pro/set-mark))
    (defun my/region/set-mark (command-name)
      (if (eq last-command command-name)
    	(if (region-active-p)
    	    (progn
    	      (deactivate-mark)
    	      (message "Mark deactivated"))
    	  (activate-mark)
    	  (message "Mark activated"))
        (set-mark-command nil))))

  ;; Add hook to format YAML buffer before save
  (defun yaml-pro-format-buffer ()
    "Format the current buffer with yaml-pro-format."
    (when (derived-mode-p 'yaml-ts-mode)
      (yaml-pro-format)))

  #+end_src

* LSP
Setting up eglot LSP

** eglot
#+begin_src emacs-lisp
  (use-package eglot
    :ensure t
    :config
    (evil-leader/set-key
      "lo" 'eglot
      "la" 'eglot-code-actions
      "lf" 'apheleia-format-buffer
      "lr" 'eglot-rename
      "lH" 'eglot-inlay-hints-mode
      "ld" 'eglot-find-declaration
      "li" 'eglot-find-implementation
      "lt" 'eglot-find-typeDefinition
      "lI" 'eglot-organize-imports
      "ln" 'flymake-goto-next-error
      "lwd" 'flymake-show-project-diagnostics
      "lbd" 'flymake-show-buffer-diagnostics))
#+end_src
** eglot-booster
#+begin_src emacs-lisp
  (use-package eglot-booster
    :after eglot
    :config
    (eglot-booster-mode))
#+end_src

* ORG
** Dslide

Programmable Org Presentation
#+begin_src emacs-lisp
   (use-package dslide
     :defer t
     :config
     ;; Add any additional configuration for dslide here
     )

   (with-eval-after-load 'dslide
     (define-key org-mode-map (kbd "C-c d s") 'dslide-start)
     (define-key org-mode-map (kbd "C-c d n") 'dslide-next)
     (define-key org-mode-map (kbd "C-c d p") 'dslide-prev))

   ;; Function to enable dslide-mode manually
   (defun enable-dslide-mode ()
     "Enable dslide-mode manually."
     (interactive)
     (dslide-mode 1))

   ;; Bind a key to enable dslide-mode manually
   (define-key org-mode-map (kbd "C-c d e") 'enable-dslide-mode)
#+end_src

** Org-Roam
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (file-truename "~/Documents/notes/src"))
    (org-roam-completion-everywhere t)
    (org-roam-capture-templates
     '(("d" "default" plain
	"%?"
	:if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
	:unnarrowed t)))
    :bind (("C-c n l" . org-roam-buffer-toggle)
	 ("C-c n f" . org-roam-node-find)
	 ("C-c n i" . org-roam-node-insert)
	 :map org-mode-map
	 ("C-M-i" . completion-at-point))
    :config
    (org-roam-setup)
    (org-roam-db-autosync-mode))

  (use-package org-modern
    :ensure t
    :hook ((org-mode . org-modern-mode)
           (org-agenda-finalize . org-modern-agenda)))

  ;; Define a prefix command for org-mode related commands
  (define-prefix-command 'org-prefix-map)

  ;; Bind the prefix command to "C-x o"
  (global-set-key (kbd "C-x o") 'org-prefix-map)

  ;; Bind org-roam-capture to "C-x o c"
  (define-key org-prefix-map (kbd "c") 'org-roam-capture)
#+end_src

* Projects
Projectile is the go-to project package to use with Emacs.
Easy to use and setup, easy use of buffers. Use counsel-projectile for more advanced features.

** Counsel
#+begin_src emacs-lisp
  (use-package counsel
    :ensure t
    :config

    (evil-leader/set-key
      "ff" 'counsel-find-file
      "fg" 'counsel-grep))

  (use-package counsel-projectile
    :after projectile
    :config
    (counsel-projectile-mode))

#+end_src

** Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-mode +1)
    :config
    (setq projectile-enable-caching t
  	projectile-completion-system 'ivy
  	projectile-indexing-method 'alien
  	projectile-sort-order 'recently-active
  	projectile-project-search-path '("~/Projects/" ("~/Projects/workspace/" . 1)))

    (evil-leader/set-key
      "pf" 'projectile-find-file
      "pp" 'projectile-switch-project
      "pc" 'projectile-cleanup-known-projects

      "<SPC>" 'projectile-switch-to-buffer))
#+end_src

* Terminal
Setup vterm as project term
- Vterm
- Vterm-toggle
- Multi-vterm

Create a fun to kill all terminals in current project
#+begin_src emacs-lisp
  (require 'cl-lib)

  (defun kill-all-terminal-buffers-in-project ()
    "Kill all terminal buffers in the current projectile project."
    (interactive)
    (let* ((project (projectile-project-name))
           (buffers (buffer-list))
           (buffer-patterns (list (format "*vterm-right-1-%s*" project)
                                  (format "*vterm-left-%s*" project)
                                  (format "*vterm-right-2-%s*" project)
                                  (format "*vterm-%s*" project)
                                  (format "*vterm-toggle-%s*" project))))
      (dolist (buffer buffers)
        (when (and (cl-some (lambda (pattern) (string-match-p pattern (buffer-name buffer))) buffer-patterns)
                   (with-current-buffer buffer
                     (string= (projectile-project-name) project)
                     (derived-mode-p 'vterm-mode)))
          (kill-buffer buffer)))))

  (evil-leader/set-key
    "tk" 'kill-all-terminal-buffers-in-project)

#+end_src

** Vterm
#+begin_src emacs-lisp
  ;; A terminal via libvterm
  (use-package vterm
    :ensure t
    :config
    (defun projectile-vterm-toggle ()
      "Toggle a vterm buffer for the current projectile project."
      (interactive)
      (let* ((project (projectile-project-name))
	     (default-directory (projectile-project-root))
	     (buf-name (format "*vterm-%s*" project)))
	(if project
	    (if (get-buffer buf-name)
		(if (eq (current-buffer) (get-buffer buf-name))
		    (switch-to-buffer (other-buffer))
		  (switch-to-buffer buf-name))
	      (vterm buf-name))
	  (vterm))))

    (evil-leader/set-key
      "tt" 'projectile-vterm-toggle))

#+end_src

** Vterm-toggle
#+begin_src emacs-lisp
  (use-package vterm-toggle
    :ensure t
    :config
    (defun projectile-vterm-toggle-right ()
      "Toggle a vterm buffer for the current projectile project on the right."
      (interactive)
      (let* ((project (projectile-project-name))
	     (default-directory (projectile-project-root))
	     (buf-name (format "*vterm-toggle-%s*" project)))
	(if project
	    (if (get-buffer buf-name)
		(if (get-buffer-window buf-name)
		    (delete-window (get-buffer-window buf-name))
		  (progn
		    (display-buffer buf-name '((display-buffer-pop-up-window)))
		    (select-window (get-buffer-window buf-name))))
	      (progn
		(split-window-right)
		(other-window 1)
		(vterm buf-name)
		(select-window (get-buffer-window buf-name))))
	  (vterm-toggle))))

    (evil-leader/set-key
      "to" 'projectile-vterm-toggle-right))
#+end_src

** Multi-Vterm
#+begin_src emacs-lisp
  (use-package multi-vterm
    :ensure t
    :config
    (add-hook 'vterm-mode-hook
	      (lambda ()
		(setq-local evil-insert-state-cursor 'box)
		(evil-insert-state)))
    (define-key vterm-mode-map [return] #'vterm-send-return)
    (setq vterm-keymap-exceptions nil)
    (evil-define-key 'insert vterm-mode-map (kbd "C-e") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-f") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-a") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-v") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-b") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-w") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-u") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-d") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-n") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-m") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-p") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-j") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-k") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-r") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-t") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-g") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-c") #'vterm--self-insert)
    (evil-define-key 'insert vterm-mode-map (kbd "C-SPC") #'vterm--self-insert)
    (evil-define-key 'normal vterm-mode-map (kbd "C-d") #'vterm--self-insert)
    (evil-define-key 'normal vterm-mode-map (kbd ",c") #'multi-vterm)
    (evil-define-key 'normal vterm-mode-map (kbd ",n") #'multi-vterm-next)
    (evil-define-key 'normal vterm-mode-map (kbd ",p") #'multi-vterm-prev)
    (evil-define-key 'normal vterm-mode-map (kbd "i") #'evil-insert-resume)
    (evil-define-key 'normal vterm-mode-map (kbd "o") #'evil-insert-resume)
    (evil-define-key 'normal vterm-mode-map (kbd "<return>") #'evil-insert-resume)

    (defvar previous-buffer nil "Stores the previous buffer before switching to vterm layout.")

    (defun projectile-multi-vterm-toggle ()
      "Toggle three vterm buffers for the current projectile project."
      (interactive)
      (let* ((project (projectile-project-name))
             (default-directory (projectile-project-root))
             (buf-left (format "*vterm-left-%s*" project))
             (buf-right-1 (format "*vterm-right-1-%s*" project))
             (buf-right-2 (format "*vterm-right-2-%s*" project)))
        (if (and (get-buffer buf-left)
                 (get-buffer-window buf-left))
            (progn
              (delete-other-windows)
              (switch-to-buffer previous-buffer))
          (setq previous-buffer (current-buffer))
          (delete-other-windows)
          (split-window-right)
          (other-window 1)
          (split-window-below)
          (if (get-buffer buf-right-1)
              (switch-to-buffer buf-right-1)
            (vterm buf-right-1))
          (other-window 1)
          (if (get-buffer buf-right-2)
              (switch-to-buffer buf-right-2)
            (vterm buf-right-2))
          (other-window 1)
          (if (get-buffer buf-left)
              (switch-to-buffer buf-left)
            (vterm buf-left))
          (other-window 1))))

    (evil-leader/set-key
      "tl" 'projectile-multi-vterm-toggle))
#+end_src

* Version
Using magit with forge, creates the best environment for working with
Git inside Emacs, the only thing missing here is a way to approve PR.
For forge, create a file called ~/.authinfo with the following:

- machine api.github.com login gako358^forge password ==secret-token==

** blamer
#+begin_src emacs-lisp
  (use-package blamer
    :custom
    (blamer-idle-time 0.3)
    (blamer-min-offset 70)

    :config
    (evil-leader/set-key
      "bm" 'blamer-mode))
#+end_src

** git-gutter
#+begin_src emacs-lisp
  (use-package git-gutter
    :hook (prog-mode . git-gutter-mode)
    :custom
    (git-gutter:update-interval 0.05))

  (use-package git-gutter-fringe
    :after git-gutter
    :config
    (fringe-mode '(8 . 8))
    (define-fringe-bitmap 'git-gutter-fr:added
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:modified
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:deleted
      [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
      nil nil 'center))
#+end_src

** magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (evil-leader/set-key
      "/" 'magit-status))
#+end_src
