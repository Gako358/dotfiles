#+STARTUP: overview
#+TITLE: MerrinX Config
#+CREATOR: Merrinx
#+LANGUAGE: en

* Installation
Git clone https://github.com/gako358/dotfiles.git.
The configuration is setup using NixOS, check README.


* Appearance
Using the dashboard package with the kaolin-theme to enhance the startup experience and overall look of Emacs.

** Bar
The vim-tab-bar package is used for managing tabs, activated after initialization.

#+begin_src emacs-lisp
  (use-package vim-tab-bar
    :ensure t
    :commands vim-tab-bar-mode
    :hook (after-init . vim-tab-bar-mode))
#+end_src

** Dashboard
The dashboard package is configured to display a welcoming startup screen with a custom banner, recent files, bookmarks, projects, and agenda items.

#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (setq dashboard-startup-banner 'logo
          dashboard-banner-logo-title "Welcome back Master"
          dashboard-set-file-icons t
          dashboard-center-content t
          dashboard-items '((recents  . 5)
                            (bookmarks . 5)
                            (projects . 5)
                            (agenda . 5))
          initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
    :init
    :hook (after-init . dashboard-setup-startup-hook))
#+end_src

** Fonts
Custom fonts are set using "Iosevka Nerd Font" for both the main text and the mode-line, ensuring a consistent and visually appealing interface across all frames.

#+begin_src emacs-lisp
  (add-hook 'after-make-frame-functions
	    (lambda (f)
	      (with-selected-frame f
		(set-frame-font "Iosevka Nerd Font 11" nil t)
		(set-face-attribute 'mode-line nil :font "Iosevka Nerd Font 12" :height 100))))

  (add-to-list 'default-frame-alist '(height . 64))
  (add-to-list 'default-frame-alist '(width . 370))
#+end_src

** Icons

All-the-icons: Provides a rich set of icons for various file types and modes.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+end_src

All-the-icons-ivy-rich: Enhances Ivy's minibuffer completion with icons, activated on startup.

#+begin_src emacs-lisp
  (use-package all-the-icons-ivy-rich
    :ensure t
    :init (all-the-icons-ivy-rich-mode 1))
#+end_src

Nerd-icons: Sets "Iosevka Nerd Font" as the icon font family.
Nerd-icons-completion: Integrates with Marginalia for enhanced completion visuals.
Nerd-icons-corfu: Adds pretty icons to Corfu completion menus.

#+begin_src emacs-lisp
  (use-package nerd-icons
    :ensure t
    :config
    (setq nerd-icons-font-family "Iosevka Nerd Font"))

  ;; Pretty icons for completion
  (use-package nerd-icons-completion
    :ensure t
    :after marginalia
    :config
    (nerd-icons-completion-marginalia-setup)
    (nerd-icons-completion-mode 1))

  (use-package nerd-icons-corfu
    :ensure t
    :after corfu
    :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

#+end_src

** Themes
The kaolin-themes package is used with specific settings for a personalized look, loading the "kaolin-ocean" theme.

#+begin_src emacs-lisp
  (use-package kaolin-themes
    :config
    (setq kaolin-ocean-alt-bg t)
    (setq kaolin-themes-italic-comments t
          kaolin-themes-hl-line-colored t
          kaolin-themes-git-gutter-solid t)
    (load-theme 'kaolin-ocean t))
#+end_src

** Session
The undo-fu-session package is configured for global session management, maintaining undo history across sessions.

#+begin_src emacs-lisp
  (use-package undo-fu-session
    :ensure t
    :config
    (undo-fu-session-global-mode))
#+end_src

* Completion
Using Corfu, vertico and cape for code completion.

#+begin_src emacs-lisp
  ;; Enable indentation and completion with the TAB key.
  (setq tab-always-indent 'complete)

  ;; Cycle with the TAB key if there are only few candidates.
  (setq completion-cycle-threshold 3)
#+end_src

** Cape
Completion At Point Extensions:
- Cape: Provides extensions for completion-at-point-functions to enhance the completion experience for files and Emacs Lisp blocks.

#+begin_src emacs-lisp
  ;; Completion At Point Extensions.
  (use-package cape
    :ensure t
    :init
    (add-hook 'completion-at-point-functions #'cape-file)
    (add-hook 'completion-at-point-functions #'cape-elisp-block)
    ;; (add-hook 'completion-at-point-functions #'cape-dabbrev) ;; Buffer completion
    ;; (add-hook 'completion-at-point-functions #'cape-history)
    )
#+end_src

** Consult
Commands Compatible with Completing-read:
- Consult: Provides various commands that integrate with completing-read for enhanced navigation and search capabilities.

#+begin_src emacs-lisp
  ;; Commands compatible with completing-read.
  (use-package consult
    :ensure t
    :bind (;; C-c bindings in `mode-specific-map'
	   ("C-c M-x" . consult-mode-command)
	   ("C-c h" . consult-history)
	   ("C-c k" . consult-kmacro)
	   ("C-c m" . consult-man)
	   ("C-c i" . consult-info)
	   ([remap Info-search] . consult-info)
	   ;; C-x bindings in `ctl-x-map'
	   ("C-x M-:" . consult-complex-command)
	   ("C-x 4 b" . consult-buffer-other-window)
	   ("C-x 5 b" . consult-buffer-other-frame)
	   ("C-x t b" . consult-buffer-other-tab)
	   ("C-x r b" . consult-bookmark)
	   ("C-x b" . consult-buffer)
	   ("C-x p b" . consult-project-buffer)
	   ;; Custom M-# bindings for fast register access
	   ("M-#" . consult-register-load)
	   ("M-'" . consult-register-store)
	   ("C-M-#" . consult-register)
	   ;; Other custom bindings
	   ("M-y" . consult-yank-pop)
	   ;; M-g bindings in `goto-map'
	   ("M-g e" . consult-compile-error)
	   ("M-g f" . consult-flymake)
	   ("M-g g" . consult-goto-line)
	   ;; ("M-g M-g" . consult-goto-line)
	   ("M-g o" . consult-outline)
	   ("M-g m" . consult-mark)
	   ("M-g k" . consult-global-mark)
	   ("M-g i" . consult-imenu)
	   ("M-g I" . consult-imenu-multi)
	   ;; M-s bindings in `search-map'
	   ("M-s d" . consult-find)
	   ("M-s c" . consult-locate)
	   ("M-s g" . consult-ripgrep)
	   ("M-s G" . consult-git-grep)
	   ("M-s l" . consult-line)
	   ("M-s L" . consult-line-multi)
	   ("M-s u" . consult-focus-lines)
	   ("M-s v" . kristian/consult-ripgrep-from-visual-selection)
	   ;; Isearch integration
	   :map isearch-mode-map
	   ("M-s L" . consult-line-multi)
	   )

    ;; Enable automatic preview at point in the *Completions* buffer.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    :init
    ;; Optionally configure the register formatting. This improves the register
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    :config
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))
    (setq consult-narrow-key "<"))
#+end_src

** Copilot
AI-Powered Code Completion:
- Copilot: Integrates GitHub Copilot for AI-powered code completion, with custom keybindings and configuration for different modes.

#+begin_src emacs-lisp
  (use-package dash :ensure t)
  (use-package s :ensure t)
  (use-package editorconfig
    :ensure t
    :config
    (editorconfig-mode 1))
  (use-package f :ensure t)
  (use-package copilot
    :ensure t
    :bind (:map copilot-completion-map
  	      ("C-e" . copilot-accept-completion)
  	      ("C-S-e" . copilot-accept-completion-by-word))
    :config
    (defun toggle-copilot-mode ()
      "Toggle Copilot mode on and off."
      (interactive)
      (if (bound-and-true-p copilot-mode)
  	(copilot-mode -1)
        (copilot-mode 1)))

    (global-set-key (kbd "C-c C-p") 'toggle-copilot-mode)

    (add-to-list 'copilot-indentation-alist '(prog-mode . 2))
    (add-to-list 'copilot-indentation-alist '(org-mode . 2))
    (add-to-list 'copilot-indentation-alist '(text-mode . 2))
    (add-to-list 'copilot-indentation-alist '(closure-mode . 2))
    (add-to-list 'copilot-indentation-alist '(nix-ts-mode . 2))
    (add-to-list 'copilot-indentation-alist '(nix-mode . 2))
    (add-to-list 'copilot-indentation-alist '(scala-ts-mode . 2))
    (add-to-list 'copilot-indentation-alist '(scala-mode . 2))
    (add-to-list 'copilot-indentation-alist '(java-ts-mode . 2))
    (add-to-list 'copilot-indentation-alist '(java-mode . 2))
    (add-to-list 'copilot-indentation-alist '(emacs-lisp-mode . 2)))
#+end_src

** Corfu
Completion Overlay Region Function:
- Corfu: Provides a completion overlay for better in-line completion, with custom keybindings for navigation and configuration for an improved user experience.

#+begin_src emacs-lisp
  ;; Completion Overlay Region Function.
  (use-package corfu
    :init
    (global-corfu-mode 1)
    (setq global-corfu-minibuffer
	  (lambda ()
	    (not (or (bound-and-true-p mct--active)
		     (bound-and-true-p vertico--input)
		     (eq (current-local-map) read-passwd-map)))))
    :bind (:map corfu-map
		("C-n" . corfu-next)
		("C-p" . corfu-previous)
		("C-h" . corfu-info-documentation)
		;; Remove the C-y binding from here since Evil intercepts it
		)

    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-preview-current nil)
    (corfu-quit-at-boundary t)
    (corfu-quit-no-match t)

    :config
    ;; Add Evil-specific binding for C-y in Corfu
    (with-eval-after-load 'evil
      (define-key evil-insert-state-map (kbd "C-y")
                  (lambda ()
                    (interactive)
                    (if (and (boundp 'corfu-mode) corfu-mode)
                        (corfu-insert)
                      (evil-paste-before 1)))))


    )
#+end_src

** Embark
Context Menu for Actions:
- Embark: Offers a context menu for performing actions on selected items directly from the completion interface.

#+begin_src emacs-lisp
  (use-package embark
    ;; Embark is an Emacs package that acts like a context menu, allowing
    ;; users to perform context-sensitive actions on selected items
    ;; directly from the completion interface.
    :ensure t
    :defer t
    :commands (embark-act
	       embark-dwim
	       embark-export
	       embark-collect
	       embark-bindings
	       embark-prefix-help-command)
    :init
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))
#+end_src

Integration with Consult:
- Embark-consult: Enhances Embark by integrating it with Consult, providing additional context-sensitive actions during completion.

#+begin_src emacs-lisp
  (use-package embark-consult
    :after embark consult
    :bind (:map minibuffer-mode-map
		("C-e Ce" . embark-export))
    :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Eldoc
#+begin_src emacs-lisp
  (use-package eldoc-box)
#+end_src

** Marginalia
Annotations for Completion Candidates:
- Marginalia: Adds rich annotations to completion candidates, enhancing the completion experience with additional context.

#+begin_src emacs-lisp
  ;; Annotations for completion candidates.
  (use-package marginalia
    ;; Marginalia allows Embark to offer you preconfigured actions in more contexts.
    ;; In addition to that, Marginalia also enhances Vertico by adding rich
    ;; annotations to the completion candidates displayed in Vertico's interface.
    :ensure t
    :defer t
    :commands (marginalia-mode marginalia-cycle)
    :hook (after-init . marginalia-mode))
#+end_src

** Orderless
Flexible Matching:
- Orderless: Provides flexible matching capabilities for completion, allowing multiple patterns to be matched in any order.

#+begin_src emacs-lisp
  ;; Space-separated matching components matching in any order.
  (use-package orderless
    ;; Vertico leverages Orderless' flexible matching capabilities, allowing users
    ;; to input multiple patterns separated by spaces, which Orderless then
    ;; matches in any order against the candidates.
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Vertico
Vertical Interactive Completion UI:
- Vertico: Offers a vertical completion interface, improving the user experience for navigating and selecting completion candidates.

#+begin_src emacs-lisp
  ;; Vertical interactive completion UI.
  ;; Tip: You can remove the `vertico-mode' use-package and replace it
  ;;      with the built-in `fido-vertical-mode'.
  (use-package vertico
    ;; (Note: It is recommended to also enable the savehist package.)
    :ensure t
    :defer t
    :commands vertico-mode
    :hook (after-init . vertico-mode))
#+end_src

** Grep
Writable Grep:
- wgrep: Allows editing of grep buffers, enabling changes to be applied directly to files.

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src

** Yasnippet
Snippet Expansion:
- Yasnippet: Provides support for snippet expansion, allowing predefined templates to be used for faster coding.
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :init
    (yas-global-mode 1))
#+end_src

* Core
#+begin_src emacs-lisp
  (defvar minimal-emacs-ui-features '()
    "List of user interface features to disable in minimal Emacs setup.

  This variable holds a list Emacs UI features that can be enabled:
  - `context-menu`: Enables the context menu in graphical environments.
  - `tool-bar`: Enables the tool bar in graphical environments.
  - `menu-bar`: Enables the menu bar in graphical environments.
  - `dialogs`: Enables both file dialogs and dialog boxes.
  - `tooltips`: Enables tooltips.

  Each feature in the list corresponds to a specific UI component that can be
  turned on.")

  (defvar minimal-emacs-frame-title-format "%b â€“ Emacs"
    "Template for displaying the title bar of visible and iconified frame.")

  (defvar minimal-emacs-debug nil
    "Non-nil to enable debug.")

  (defvar minimal-emacs-gc-cons-threshold (* 16 1024 1024)
    "The value of `gc-cons-threshold' after Emacs startup.")

  (defvar minimal-emacs-package-initialize-and-refresh t
    "Whether to automatically initialize and refresh packages.
  When set to non-nil, Emacs will automatically call `package-initialize' and
  `package-refresh-contents' to set up and update the package system.")

  (defvar minimal-emacs-user-directory user-emacs-directory
    "The default value of the `user-emacs-directory' variable.")

  ;;; Load pre-early-init.el

  (defun minimal-emacs-load-user-init (filename)
    "Execute a file of Lisp code named FILENAME."
    (let ((user-init-file
           (expand-file-name filename
                             minimal-emacs-user-directory)))
      (when (file-exists-p user-init-file)
        (load user-init-file nil t))))

  (minimal-emacs-load-user-init "pre-early-init.el")

  (setq custom-theme-directory
        (expand-file-name "themes/" minimal-emacs-user-directory))
  (setq custom-file (expand-file-name "custom.el" minimal-emacs-user-directory))

  ;;; Garbage collection
  ;; Garbage collection significantly affects startup times. This setting delays
  ;; garbage collection during startup but will be reset later.

  (setq gc-cons-threshold most-positive-fixnum)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold minimal-emacs-gc-cons-threshold)))

  ;;; Misc

  (set-language-environment "UTF-8")

  ;; Set-language-environment sets default-input-method, which is unwanted.
  (setq default-input-method nil)

  ;;; Performance

  ;; Prefer loading newer compiled files
  (setq load-prefer-newer t)

  ;; Font compacting can be very resource-intensive, especially when rendering
  ;; icon fonts on Windows. This will increase memory usage.
  (setq inhibit-compacting-font-caches t)

  (unless (daemonp)
    (let ((old-value (default-toplevel-value 'file-name-handler-alist)))
      (set-default-toplevel-value
       'file-name-handler-alist
       ;; Determine the state of bundled libraries using calc-loaddefs.el.
       ;; If compressed, retain the gzip handler in `file-name-handler-alist`.
       ;; If compiled or neither, omit the gzip handler during startup for
       ;; improved startup and package load time.
       (if (eval-when-compile
             (locate-file-internal "calc-loaddefs.el" load-path))
           nil
         (list (rassq 'jka-compr-handler old-value))))
      ;; Ensure the new value persists through any current let-binding.
      (set-default-toplevel-value 'file-name-handler-alist
                                  file-name-handler-alist)
      ;; Remember the old value to reset it as needed.
      (add-hook 'emacs-startup-hook
                (lambda ()
                  (set-default-toplevel-value
                   'file-name-handler-alist
                   ;; Merge instead of overwrite to preserve any changes made
                   ;; since startup.
                   (delete-dups (append file-name-handler-alist old-value))))
                101))

    (unless noninteractive
      (unless minimal-emacs-debug
        (unless minimal-emacs-debug
          ;; Suppress redisplay and redraw during startup to avoid delays and
          ;; prevent flashing an unstyled Emacs frame.
          ;; (setq-default inhibit-redisplay t) ; Can cause artifacts
          (setq-default inhibit-message t)

          ;; Reset the above variables to prevent Emacs from appearing frozen or
          ;; visually corrupted after startup or if a startup error occurs.
          (defun minimal-emacs--reset-inhibited-vars-h ()
            ;; (setq-default inhibit-redisplay nil) ; Can cause artifacts
            (setq-default inhibit-message nil)
            (remove-hook 'post-command-hook #'minimal-emacs--reset-inhibited-vars-h))

          (add-hook 'post-command-hook
                    #'minimal-emacs--reset-inhibited-vars-h -100))

        (dolist (buf (buffer-list))
          (with-current-buffer buf
            (setq mode-line-format nil)))

        (put 'mode-line-format 'initial-value
             (default-toplevel-value 'mode-line-format))
        (setq-default mode-line-format nil)

        (defun minimal-emacs--startup-load-user-init-file (fn &rest args)
          "Advice for startup--load-user-init-file to reset mode-line-format."
          (unwind-protect
              (progn
                ;; Start up as normal
                (apply fn args))
            ;; If we don't undo inhibit-{message, redisplay} and there's an
            ;; error, we'll see nothing but a blank Emacs frame.
            (setq-default inhibit-message nil)
            (unless (default-toplevel-value 'mode-line-format)
              (setq-default mode-line-format
                            (get 'mode-line-format 'initial-value)))))

        (advice-add 'startup--load-user-init-file :around
                    #'minimal-emacs--startup-load-user-init-file))

      ;; Without this, Emacs will try to resize itself to a specific column size
      (setq frame-inhibit-implied-resize t)

      ;; A second, case-insensitive pass over `auto-mode-alist' is time wasted.
      ;; No second pass of case-insensitive search over auto-mode-alist.
      (setq auto-mode-case-fold nil)

      ;; Reduce *Message* noise at startup. An empty scratch buffer (or the
      ;; dashboard) is more than enough, and faster to display.
      (setq inhibit-startup-screen t
            inhibit-startup-echo-area-message user-login-name)
      (setq initial-buffer-choice nil
            inhibit-startup-buffer-menu t
            inhibit-x-resources t)

      ;; Disable bidirectional text scanning for a modest performance boost.
      (setq-default bidi-display-reordering 'left-to-right
                    bidi-paragraph-direction 'left-to-right)

      ;; Give up some bidirectional functionality for slightly faster re-display.
      (setq bidi-inhibit-bpa t)

      ;; Remove "For information about GNU Emacs..." message at startup
      (advice-add #'display-startup-echo-area-message :override #'ignore)

      ;; Suppress the vanilla startup screen completely. We've disabled it with
      ;; `inhibit-startup-screen', but it would still initialize anyway.
      (advice-add #'display-startup-screen :override #'ignore)

      ;; Shave seconds off startup time by starting the scratch buffer in
      ;; `fundamental-mode'
      (setq initial-major-mode 'fundamental-mode
            initial-scratch-message nil)

      (unless minimal-emacs-debug
        ;; Unset command line options irrelevant to the current OS. These options
        ;; are still processed by `command-line-1` but have no effect.
        (unless (eq system-type 'darwin)
          (setq command-line-ns-option-alist nil))
        (unless (memq initial-window-system '(x pgtk))
          (setq command-line-x-option-alist nil)))))

  ;;; Native compilation and Byte compilation

  (if (and (featurep 'native-compile)
           (fboundp 'native-comp-available-p)
           (native-comp-available-p))
      ;; Activate `native-compile'
      (setq native-comp-jit-compilation t
            native-comp-deferred-compilation t  ; Obsolete since Emacs 29.1
            package-native-compile t)
    ;; Deactivate the `native-compile' feature if it is not available
    (setq features (delq 'native-compile features)))

  ;; Suppress compiler warnings and don't inundate users with their popups.
  (setq native-comp-async-report-warnings-errors
        (or minimal-emacs-debug 'silent))
  (setq native-comp-warning-on-missing-source minimal-emacs-debug)

  (setq debug-on-error minimal-emacs-debug
        jka-compr-verbose minimal-emacs-debug)

  (setq byte-compile-warnings minimal-emacs-debug)
  (setq byte-compile-verbose minimal-emacs-debug)

  ;;; UI elements

  (setq frame-title-format minimal-emacs-frame-title-format
        icon-title-format minimal-emacs-frame-title-format)

  ;; Disable startup screens and messages
  (setq inhibit-splash-screen t)

  ;; I intentionally avoid calling `menu-bar-mode', `tool-bar-mode', and
  ;; `scroll-bar-mode' because manipulating frame parameters can trigger or queue
  ;; a superfluous and potentially expensive frame redraw at startup, depending
  ;; on the window system. The variables must also be set to `nil' so users don't
  ;; have to call the functions twice to re-enable them.
  (unless (memq 'menu-bar minimal-emacs-ui-features)
    (push '(menu-bar-lines . 0) default-frame-alist)
    (unless (memq window-system '(mac ns))
      (setq menu-bar-mode nil)))

  (unless (daemonp)
    (unless noninteractive
      (when (fboundp 'tool-bar-setup)
        ;; Temporarily override the tool-bar-setup function to prevent it from
        ;; running during the initial stages of startup
        (advice-add #'tool-bar-setup :override #'ignore)
        (define-advice startup--load-user-init-file
            (:after (&rest _) minimal-emacs-setup-toolbar)
          (advice-remove #'tool-bar-setup #'ignore)
          (when tool-bar-mode
            (tool-bar-setup))))))
  (unless (memq 'tool-bar minimal-emacs-ui-features)
    (push '(tool-bar-lines . 0) default-frame-alist)
    (setq tool-bar-mode nil))

  (push '(vertical-scroll-bars) default-frame-alist)
  (push '(horizontal-scroll-bars) default-frame-alist)
  (setq scroll-bar-mode nil)
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))

  (unless (memq 'tooltips minimal-emacs-ui-features)
    (when (bound-and-true-p tooltip-mode)
      (tooltip-mode -1)))

  ;; Disable GUIs because they are inconsistent across systems, desktop
  ;; environments, and themes, and they don't match the look of Emacs.
  (unless (memq 'dialogs minimal-emacs-ui-features)
    (setq use-file-dialog nil)
    (setq use-dialog-box nil))

  ;;; LSP
  (setenv "LSP_USE_PLISTS" "true")

  ;; Disable sound bell
  (setq visible-bell 1)

#+end_src

* Edit
Edit, format, and grammar support for various programming languages and markdown.

** Apheleia
Formatters:
- Apheleia: Provides on-the-fly code formatting using various formatters:
  -  Scalafmt for Scala
  -  Black for Python
  -  Prettier for TypeScript and JavaScript
  -  Google Java Format for Java
  -  nixpkgs-fmt for Nix

#+begin_src emacs-lisp
  ;; Formatters
  (use-package apheleia
    :config
    ;; Add scalafmt for Scala
    (push '(scalafmt . ("scalafmt" "--stdin" "--non-interactive" "--quiet" "--stdout")) apheleia-formatters)
    (push '(scala-ts-mode . scalafmt) apheleia-mode-alist)

    ;; Add black for Python
    (push '(black . ("black" "-")) apheleia-formatters)
    (push '(python-mode . black) apheleia-mode-alist)

    ;; Add prettier for TypeScript and JavaScript
    (push '(prettier . ("prettier" "--stdin-filepath" buffer-file-name)) apheleia-formatters)
    (push '(typescript-ts-mode . prettier) apheleia-mode-alist)
    (push '(js-ts-mode . prettier) apheleia-mode-alist)

    ;; Add google-java-format for Java
    (push '(google-java-format . ("google-java-format" "-")) apheleia-formatters)
    (push '(java-ts-mode . google-java-format) apheleia-mode-alist)

    ;; Add nixpkgs-fmt for Nix
    (push '(nixpkgs-fmt . ("nixpkgs-fmt")) apheleia-formatters)
    (push '(nix-mode . nixpkgs-fmt) apheleia-mode-alist))

  (apheleia-global-mode +1)
#+end_src

* Filetree
Config dirvish

#+begin_src emacs-lisp
  (use-package dirvish
    :ensure t
    :init
    (dirvish-override-dired-mode)
    :custom
    (dirvish-quick-access-entries ; It's a custom option, `setq' won't work
     '(("h" "~/"                          "Home")
       ("d" "~/Downloads/"                "Downloads")
       ("m" "/mnt/"                       "Drives")
       ("p" "~/src/"                      "Projects")
       ("t" "~/.local/share/Trash/files/" "TrashCan")))

    :config
    ;; (dirvish-peek-mode)             ; Preview files in minibuffer
    ;; (dirvish-side-follow-mode)      ; similar to `treemacs-follow-mode'
    (setq dirvish-mode-line-format
          '(:left (sort symlink) :right (omit yank index)))
    (setq dirvish-attributes           ; The order *MATTERS* for some attributes
          '(vc-state subtree-state nerd-icons collapse git-msg file-time file-size)
          dirvish-side-attributes
          '(vc-state nerd-icons collapse file-size))
    (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
          "-l --almost-all --human-readable --group-directories-first --no-group")
    :bind ; Bind `dirvish-fd|dirvish-side|dirvish-dwim' as you see fit
    ((:map dirvish-mode-map          ; Dirvish inherits `dired-mode-map'
           ;; ("M-?"   . dirvish-dispatch)     ; contains most of sub-menus in dirvish extensions
           ("M-a"   . dirvish-quick-access)
           ("M-f"   . dirvish-file-info-menu)
           ("M-y"   . dirvish-yank-menu)
           ;; ("N"   . dirvish-narrow)
           ;; ("^"   . dirvish-history-last)
           ("M-h" . dired-up-directory)
           ("M-n" . dired-create-empty-file)
           ;; ("H"   . dirvish-history-jump) ; remapped `describe-mode'
           ;; ("s"   . dirvish-quicksort)    ; remapped `dired-sort-toggle-or-edit'
           ("M-v"   . dirvish-vc-menu)      ; remapped `dired-view-file'
           ("M-o" . dirvish-subtree-toggle)
           ;; ("M-f" . dirvish-history-go-forward)
           ;; ("M-b" . dirvish-history-go-backward)
           ("M-l" . dirvish-ls-switches-menu)
           ("M-m" . dirvish-mark-menu)
           ("M-t" . dirvish-layout-toggle)
           ("M-s" . dirvish-setup-menu)
           ("M-e" . dirvish-emerge-menu)
           ("M-q" . dirvish-quit)
           ("M-j" . dirvish-fd-jump))))

  (add-hook 'dirvish-setup-hook (lambda ()
                                  (visual-line-mode -1)
                                  (setq-local truncate-lines t)))
#+end_src
* General
#+begin_src emacs-lisp
  ;; Ensure Emacs loads the most recent byte-compiled files.
  (setq load-prefer-newer t)

  ;; Ensure JIT compilation is enabled for improved performance by
  ;; native-compiling loaded .elc files asynchronously
  (setq native-comp-jit-compilation t)
                                          ;(setq native-comp-deferred-compilation t) ; Deprecated in Emacs > 29.1

                                          ;(use-package compile-angel
                                          ;  :ensure t
                                          ;  :demand t
                                          ;  :config
                                          ;  (compile-angel-on-load-mode)
                                          ;  (add-hook 'emacs-lisp-mode-hook #'compile-angel-on-save-local-mode))

  ;; Auto-revert in Emacs is a feature that automatically updates the
  ;; contents of a buffer to reflect changes made to the underlying file
  ;; on disk.
  (add-hook 'after-init-hook #'global-auto-revert-mode)

  ;; recentf is an Emacs package that maintains a list of recently
  ;; accessed files, making it easier to reopen files you have worked on
  ;; recently.
  (add-hook 'after-init-hook #'recentf-mode)

  ;; savehist is an Emacs feature that preserves the minibuffer history between
  ;; sessions. It saves the history of inputs in the minibuffer, such as commands,
  ;; search strings, and other prompts, to a file. This allows users to retain
  ;; their minibuffer history across Emacs restarts.
  (add-hook 'after-init-hook #'savehist-mode)

  ;; save-place-mode enables Emacs to remember the last location within a file
  ;; upon reopening. This feature is particularly beneficial for resuming work at
  ;; the precise point where you previously left off.
  (add-hook 'after-init-hook #'save-place-mode)

  ;; Turn on which-key-mode
  (add-hook 'after-init-hook 'which-key-mode)

  ;; Turn off autosave-mode
  ;; turn off backup-files
  (auto-save-mode -1)
  (setq make-backup-files nil)
  (setq auto-save-default nil)

  ;;; Line numbers
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode)

  ;;; Direnv integration
  (use-package envrc
    :hook (after-init . envrc-global-mode))

#+end_src
* Grammars
Setting up treesitter grammars
#+begin_src emacs-lisp
  (use-package treesit
    :ensure nil
    :custom
    (treesit-font-lock-level 4) ;; Set font lock level for Tree-sitter
    :config
    (seq-do (lambda (it)
	      (push it major-mode-remap-alist))
	    '((css-mode . css-ts-mode) ;; Remap CSS mode to Tree-sitter mode
	      (c-mode . c-ts-mode) ;; Remap C mode to Tree-sitter mode
	      (dockerfile-mode . dockerfile-ts-mode) ;; Remap Dockerfile mode to Tree-sitter mode
	      (haskell-mode . haskell-ts-mode) ;; Remap Haskell mode to Tree-sitter mode
	      (java-mode . java-ts-mode) ;; Remap Java mode to Tree-sitter mode
	      (javascript-mode . js-ts-mode) ;; Remap JavaScript mode to Tree-sitter mode
	      (python-mode . python-ts-mode) ;; Remap Python mode to Tree-sitter mode
	      (scala-mode . scala-ts-mode) ;; Remap Scala mode to Tree-sitter mode
	      (sh-mode . bash-ts-mode) ;; Remap Shell Script mode to Tree-sitter mode
	      (shell-script-mode . bash-ts-mode) ;; Remap Shell Script mode to Tree-sitter mode
	      (typescript-mode . typescript-ts-mode) ;; Remap TypeScript mode to Tree-sitter mode
	      (yaml-mode . yaml-ts-mode)))) ;; Remap YAML mode to Tree-sitter mode
#+end_src

* Keybindings
Keys that I have binded to my keyboard for easy navigation in emacs

** Evil Mode
#+begin_src emacs-lisp
  ;; evil-want-keybinding must be declared before Evil and Evil Collection
  (setq evil-want-keybinding nil)

  (use-package evil
    :ensure t
    :init
    (setq evil-undo-system 'undo-fu)
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    :custom
    (evil-want-Y-yank-to-eol t)
    :config
    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-mode 1))

  ;; Define scroll up
  (define-key evil-normal-state-map (kbd "C-u") 'evil-scroll-up)
  (define-key evil-visual-state-map (kbd "C-u") 'evil-scroll-up)
  (define-key evil-insert-state-map (kbd "C-u")
    	    (lambda ()
    	      (interactive)
    	      (evil-delete (point-at-bol) (point))))

  ;; Evil numbers inc and dec
  (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-visual-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-x") 'evil-numbers/dec-at-pt)
  (define-key evil-visual-state-map (kbd "C-x") 'evil-numbers/dec-at-pt)


  ;; Unbind default window management keys
  ;; (define-key evil-normal-state-map (kbd "C-w") nil)
  ;; (define-key evil-motion-state-map (kbd "C-w") nil)

  ;; Bind new keys for window management
  ;; (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
  ;; (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  ;; (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  ;; (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
  ;; (define-key evil-normal-state-map (kbd "C-x") 'evil-window-split)
  ;; (define-key evil-normal-state-map (kbd "C-v") 'evil-window-vsplit)

  ;; Optionally, you can also bind in motion state if you prefer
  ;; (define-key evil-motion-state-map (kbd "C-l") 'evil-window-right)
  ;; (define-key evil-motion-state-map (kbd "C-h") 'evil-window-left)
  ;; (define-key evil-motion-state-map (kbd "C-j") 'evil-window-down)
  ;; (define-key evil-motion-state-map (kbd "C-k") 'evil-window-up)
  ;; (define-key evil-motion-state-map (kbd "C-x") 'evil-window-split)
  ;; (define-key evil-motion-state-map (kbd "C-v") 'evil-window-vsplit)

  ;; Optionally bind in insert state if you want the same behavior while editing text
  ;; (define-key evil-insert-state-map (kbd "C-l") 'evil-window-right)
  ;; (define-key evil-insert-state-map (kbd "C-h") 'evil-window-left)
  ;; (define-key evil-insert-state-map (kbd "C-j") 'evil-window-down)
  ;; (define-key evil-insert-state-map (kbd "C-k") 'evil-window-up)
  ;; (define-key evil-insert-state-map (kbd "C-x") 'evil-window-split)
  ;; (define-key evil-insert-state-map (kbd "C-v") 'evil-window-vsplit))
#+end_src

** Evil Leader
#+begin_src emacs-lisp
  (use-package evil-leader)
  (global-evil-leader-mode)
  (evil-leader/set-leader "<SPC>")
  (evil-leader/set-key
    ;; Project
    "fb" 'counsel-find-file
    "ff" 'projectile-find-file
    "fg" 'projectile-ripgrep
    "pp" 'projectile-switch-project
    "pc" 'projectile-cleanup-known-projects

    "<SPC>" 'projectile-switch-to-buffer

    ;; Buffers
    "bb" 'switch-to-buffer
    "bd" 'kill-buffer
    "bn" 'next-buffer
    "bp" 'previous-buffer

    ;; Git
    "/" 'magit-status
    "bm" 'blamer-mode

    ;; LSP
    "lo" 'eglot
    "la" 'eglot-code-actions
    "lf" 'apheleia-format-buffer
    "lr" 'eglot-rename
    "lH" 'gelot-nlay-hints-mode
    "ld" 'eglot-find-declaration
    "li" 'egliot-find-implementation
    "lt" 'eglot-find-typeDefinition
    "lI" 'eglot-organize-import
    "ln" 'flymake-goto-next-error
    "lh"  'eldoc-box-help-at-point
    "lwd" 'flymake-show-project-diagnostics
    "lbd" 'flymake-show-buffer-diagnostics

    ;; Dirvish
    "rf" 'dirvish

    ;; Vterm
    "tl" 'vterm-layout
    "tr" 'toggle-vterm-right
    "tk" 'kill-all-vterms-in-project
    "tt" 'toggle-vterm
    "t1" (lambda () (interactive) (toggle-vterm 1))
    "t2" (lambda () (interactive) (toggle-vterm 2))
    "t3" (lambda () (interactive) (toggle-vterm 3))
    "t4" (lambda () (interactive) (toggle-vterm 4))
    "t5" (lambda () (interactive) (toggle-vterm 5))
    "t6" (lambda () (interactive) (toggle-vterm 6))
    "t7" (lambda () (interactive) (toggle-vterm 7))
    "t8" (lambda () (interactive) (toggle-vterm 8))
    "t9" (lambda () (interactive) (toggle-vterm 9)))
#+end_src

** Evil Collection
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :ensure t
    :hook (evil-mode . evil-collection-init)
    :bind (([remap evil-show-marks] . evil-collection-consult-mark)
           ([remap evil-show-jumps] . evil-collection-consult-jump-list))
    :config
    ;; Make `evil-collection-consult-mark' and `evil-collection-consult-jump-list'
    ;; immediately available.
    (evil-collection-require 'consult)
    :custom
    (evil-collection-setup-debugger-keys nil)
    (evil-collection-calendar-want-org-bindings t)
    (evil-collection-unimpaired-want-repeat-mode-integration t))
#+end_src

** Evil Visual Star
#+begin_src emacs-lisp
  (use-package evil-visualstar
    :after evil
    :ensure t
    :defer t
    :commands global-evil-visualstar-mode
    :hook (after-init . global-evil-visualstar-mode))
#+end_src

** Evil Surround
#+begin_src emacs-lisp
  (use-package evil-surround
    :after evil
    :ensure t
    :defer t
    :commands global-evil-surround-mode
    :custom
    (evil-surround-pairs-alist
     '((?\( . ("(" . ")"))
       (?\[ . ("[" . "]"))
       (?\{ . ("{" . "}"))

       (?\) . ("(" . ")"))
       (?\] . ("[" . "]"))
       (?\} . ("{" . "}"))

       (?< . ("<" . ">"))
       (?> . ("<" . ">"))))
    :hook (after-init . global-evil-surround-mode))
#+end_src

** Evil Keybindings
#+begin_src emacs-lisp
  (with-eval-after-load "evil"
    (evil-define-operator my-evil-comment-or-uncomment (beg end)
      "Toggle comment for the region between BEG and END."
      (interactive "<r>")
      (comment-or-uncomment-region beg end))
    (evil-define-key 'normal 'global (kbd "gc") 'my-evil-comment-or-uncomment))

  (defun move-right-and-open-todo ()
    (interactive)
    (split-window-right)
    (windmove-right)
    (find-file "~/Documents/notes/org/todo.org"))

  (defun replace-word-at-point ()
    "Replace all occurrences of the word at point with a user-provided word in the current buffer."
    (let ((old-word (thing-at-point 'word))
          (new-word (read-string "Enter new word: ")))
      (save-excursion
        (goto-char (point-min))
        (while (search-forward old-word nil t)
          (replace-match new-word)))))

  (global-set-key (kbd "C-S-i") 'move-right-and-open-todo)

  (defun move-text-internal (arg)
    (cond
     ((and mark-active transient-mark-mode)
      (if (> (point) (mark))
          (exchange-point-and-mark))
      (let ((column (current-column))
            (text (delete-and-extract-region (point) (mark))))
        (forward-line arg)
        (move-to-column column t)
        (set-mark (point))
        (insert text)
        (exchange-point-and-mark)
        (setq deactivate-mark nil)))
     (t
      (beginning-of-line)
      (when (or (> arg 0) (not (bobp)))
        (forward-line)
        (when (or (< arg 0) (not (eobp)))
          (transpose-lines arg))
        (forward-line -1)))))

  (defun move-text-down (arg)
    (interactive "*p")
    (move-text-internal arg))

  (defun move-text-up (arg)
    (interactive "*p")
    (move-text-internal (- arg)))

  (global-set-key (kbd "S-<up>") 'move-text-up)
  (global-set-key (kbd "S-<down>") 'move-text-down)
  (global-set-key (kbd "C-S-<right>") 'enlarge-window-horizontally)
  (global-set-key (kbd "C-S-<left>") 'shrink-window-horizontally)
  (global-set-key (kbd "C-S-<down>") 'shrink-window)
  (global-set-key (kbd "C-S-<up>") 'enlarge-window)
  (global-set-key (kbd "C-<tab>") 'evil-switch-to-windows-last-buffer)
#+end_src

* Languages
Using Eglot, Emacs built-in LSP client.
Setup using:
- C
- Dockerfile
- Haskell
- Java
- Markdown
- Nix
- Rust
- SBT and Scala
- SQL
- Typescript
- Yaml

Using own created web mode, for Vue, TypeScript, and Tailwind.

** C
#+begin_src emacs-lisp
  ;; C language server
  (use-package c-ts-mode
    :hook (c-ts-mode . eglot-ensure)
    :mode (("\\.c\\'" . c-ts-mode)
	   ("\\.h\\'" . c-ts-mode)))
    #+end_src

** Dockerfile

#+begin_src emacs-lisp
  (use-package dockerfile-ts-mode)
#+end_src

** Haskell
#+begin_src emacs-lisp
  (use-package haskell-ts-mode
    :mode (("\\.hs\\'" . haskell-ts-mode)
	   ("\\.cabal\\'" . haskell-ts-mode)))
#+end_src

** Java
#+begin_src emacs-lisp
  ;; Java language server
  (use-package eglot-java
    :init
    :hook (java-ts-mode . eglot-java-mode)
    :config
    (define-key eglot-java-mode-map (kbd "C-c l n") #'eglot-java-file-new)
    (define-key eglot-java-mode-map (kbd "C-c l x") #'eglot-java-run-main)
    (define-key eglot-java-mode-map (kbd "C-c l t") #'eglot-java-run-test)
    (define-key eglot-java-mode-map (kbd "C-c l N") #'eglot-java-project-new)
    (define-key eglot-java-mode-map (kbd "C-c l T") #'eglot-java-project-build-task)
    (define-key eglot-java-mode-map (kbd "C-c l R") #'eglot-java-project-build-refresh))

  (with-eval-after-load 'eglot-java)

#+end_src

** Markdown Mode
Markdown Edit:
- Markdown Mode: Provides support for editing markdown files, enhancing the writing and formatting experience.

#+begin_src emacs-lisp
  ;; Markdown edit
  (use-package markdown-mode)
#+end_src

** Nix
#+begin_src emacs-lisp
  (use-package nix-ts-mode
    :mode "\\.nix\\'"
    :init
    (setq nix-ts-indent-offset 2)
    :hook ((nix-ts-mode . eglot-ensure)
	   (before-save . eglot-format-buffer)))

  (with-eval-after-load 'eglot
    (message "Loading eglot configuration for nix-ts-mode")
    (add-to-list 'eglot-server-programs
                 '(nix-ts-mode . ("nil" "--stdio")))

    (setq eglot-workspace-configuration
          '((:nil . ((formatting . ((command . "nixpkgs-fmt")))))))

    (message "Eglot configuration set for nix-ts-mode"))

  (defun nixpkgs-fmt-before-save ()
    "Format the current buffer with nixpkgs-fmt before saving."
    (message "Running nixpkgs-fmt-before-save")
    (when (eq major-mode 'nix-ts-mode)
      (let ((current-point (point))) ;; Save the current point
        (shell-command-on-region (point-min) (point-max) "nixpkgs-fmt" nil t)
        (goto-char current-point)))) ;; Restore the point after formatting
#+end_src

** Rust
#+begin_src emacs-lisp
  ;; Rust language server
  (use-package rust-ts-mode
    :mode "\\.rs\\'"
    :hook
    (rust-ts-mode-hook . eglot-ensure)
    :init
    (with-eval-after-load 'org
      (cl-pushnew '("rust" . rust-ts-mode) org-src-lang-modes :test #'equal)))
#+end_src

** Scala
#+begin_src emacs-lisp
  ;; Scala language server
  (use-package scala-ts-mode
    :init
    (setq scala-ts-indent-offset 2)
    :hook ((scala-ts-mode . eglot-ensure)
	   (before-save . eglot-format-buffer)))

  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(scala-ts-mode . ("metals"))))
#+end_src

** SQL
#+begin_src emacs-lisp
  ;; SQL syntax-based indentation
  (use-package sql-indent
    :ensure t
    :hook (sql-mode . sqlind-minor-mode))

  (with-eval-after-load 'sql-indent
    (add-hook 'sql-mode-hook 'sqlind-minor-mode))
#+end_src

** TypeScript
#+begin_src emacs-lisp
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flymake-mode +1)
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1))

  ;; formats the buffer before saving
  (add-hook 'before-save-hook 'tide-format-before-save)
  (add-hook 'typescript-ts-mode-hook #'setup-tide-mode)

  ;; for js-ts-mode with eglot
  (use-package js-ts-mode
    :after eglot
    :hook (js-ts-mode . eglot-ensure)
    :mode
    (("\\.js\\'" . js-ts-mode)
     ("\\.ts\\'" . js-ts-mode)))
#+end_src

** Vue
#+begin_src emacs-lisp
  ;; Vue language support
  (use-package vue-ts-mode
    :after eglot
    :hook (vue-ts-mode . eglot-ensure)
    :mode
    (("\\.vue\\'" . vue-ts-mode)))
#+end_src

** Web Mode
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :mode
    (("\\.phtml\\'" . web-mode)
     ("\\.php\\'" . web-mode)
     ("\\.tpl\\'" . web-mode)
     ("\\.[agj]sp\\'" . web-mode)
     ("\\.as[cp]x\\'" . web-mode)
     ("\\.erb\\'" . web-mode)
     ("\\.mustache\\'" . web-mode)
     ("\\.djhtml\\'" . web-mode)))
#+end_src

** Yaml
#+begin_src emacs-lisp
  ;; Ensure yaml-ts-mode is always enabled for YAML files
  (use-package yaml-ts-mode
    :ensure t
    :mode ("\\.yml\\'" . yaml-ts-mode)
    ("\\.yaml\\'" . yaml-ts-mode))

  ;; Use-package configuration for yaml-pro with tree-sitter support
  (use-package yaml-pro
    :ensure t
    :after treesit
    :hook ((yaml-ts-mode . yaml-pro-ts-mode)
    	 (yaml-mode . yaml-ts-mode)
    	 (before-save . yaml-pro-format-buffer))
    :config
    ;; Add keybindings for tree-sitter mode
    (define-key yaml-pro-ts-mode-map (kbd "M-RET") #'yaml-pro-ts-meta-return)
    (define-key yaml-pro-ts-mode-map (kbd "M-?") #'yaml-pro-ts-convolute-tree)
    (define-key yaml-pro-ts-mode-map (kbd "C-c @") #'yaml-pro-ts-mark-subtree)
    (define-key yaml-pro-ts-mode-map (kbd "C-c C-x C-y") #'yaml-pro-ts-paste-subtree)
    ;; Pretty formatter keybinding
    (define-key yaml-pro-ts-mode-map (kbd "C-c C-f") #'yaml-pro-format)
    ;; Easy movement with repeat map
    (keymap-set yaml-pro-ts-mode-map "C-M-n" #'yaml-pro-ts-next-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-p" #'yaml-pro-ts-prev-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-u" #'yaml-pro-ts-up-level)
    (keymap-set yaml-pro-ts-mode-map "C-M-d" #'yaml-pro-ts-down-level)
    (keymap-set yaml-pro-ts-mode-map "C-M-k" #'yaml-pro-ts-kill-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-<backspace>" #'yaml-pro-ts-kill-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-a" #'yaml-pro-ts-first-sibling)
    (keymap-set yaml-pro-ts-mode-map "C-M-e" #'yaml-pro-ts-last-sibling)
    (defvar-keymap my/yaml-pro/tree-repeat-map
      :repeat t
      "n" #'yaml-pro-ts-next-subtree
      "p" #'yaml-pro-ts-prev-subtree
      "u" #'yaml-pro-ts-up-level
      "d" #'yaml-pro-ts-down-level
      "m" #'yaml-pro-ts-mark-subtree
      "k" #'yaml-pro-ts-kill-subtree
      "a" #'yaml-pro-ts-first-sibling
      "e" #'yaml-pro-ts-last-sibling
      "SPC" #'my/yaml-pro/set-mark)
    (defun my/yaml-pro/set-mark ()
      (interactive)
      (my/region/set-mark 'my/yaml-pro/set-mark))
    (defun my/region/set-mark (command-name)
      (if (eq last-command command-name)
    	(if (region-active-p)
    	    (progn
    	      (deactivate-mark)
    	      (message "Mark deactivated"))
    	  (activate-mark)
    	  (message "Mark activated"))
        (set-mark-command nil))))

  ;; Add hook to format YAML buffer before save
  (defun yaml-pro-format-buffer ()
    "Format the current buffer with yaml-pro-format."
    (when (derived-mode-p 'yaml-ts-mode)
      (yaml-pro-format)))

  #+end_src

* LSP
Setting up eglot LSP

** eglot-booster
#+begin_src emacs-lisp
  (use-package eglot-booster
    :after eglot
    :config
    (eglot-booster-mode))
#+end_src

* ORG
** Dslide

Programmable Org Presentation
#+begin_src emacs-lisp
   (use-package dslide
     :defer t
     :config
     ;; Add any additional configuration for dslide here
     )

   (with-eval-after-load 'dslide
     (define-key org-mode-map (kbd "C-c d s") 'dslide-start)
     (define-key org-mode-map (kbd "C-c d n") 'dslide-next)
     (define-key org-mode-map (kbd "C-c d p") 'dslide-prev))

   ;; Function to enable dslide-mode manually
   (defun enable-dslide-mode ()
     "Enable dslide-mode manually."
     (interactive)
     (dslide-mode 1))

   ;; Bind a key to enable dslide-mode manually
   (define-key org-mode-map (kbd "C-c d e") 'enable-dslide-mode)
#+end_src

** Org-Roam
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (file-truename "~/Documents/notes/src"))
    (org-roam-completion-everywhere t)
    (org-roam-capture-templates
     '(("d" "default" plain
	"%?"
	:if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
	:unnarrowed t)))
    :bind (("C-c n l" . org-roam-buffer-toggle)
	 ("C-c n f" . org-roam-node-find)
	 ("C-c n i" . org-roam-node-insert)
	 :map org-mode-map
	 ("C-M-i" . completion-at-point))
    :config
    (org-roam-setup)
    (org-roam-db-autosync-mode))

  (use-package org-modern
    :ensure t
    :hook ((org-mode . org-modern-mode)
           (org-agenda-finalize . org-modern-agenda)))

  ;; Define a prefix command for org-mode related commands
  (define-prefix-command 'org-prefix-map)

  ;; Bind the prefix command to "C-x o"
  (global-set-key (kbd "C-x o") 'org-prefix-map)

  ;; Bind org-roam-capture to "C-x o c"
  (define-key org-prefix-map (kbd "c") 'org-roam-capture)
#+end_src

* Projects
Projectile is the go-to project package to use with Emacs.
Easy to use and setup, easy use of buffers.

** Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-mode +1)
    :config
    (setq projectile-enable-caching t
          projectile-completion-system 'ivy
          projectile-indexing-method 'alien
          projectile-sort-order 'recently-active
          projectile-project-search-path '("~/Projects/" ("~/Projects/workspace/" . 1))))
#+end_src

#+begin_src emacs-lisp
  (use-package counsel-projectile
    :after projectile
    :config
    (counsel-projectile-mode))
#+end_src

* Terminal
** Vterm
Setup vterm for project term

#+begin_src emacs-lisp
  ;; A terminal via libvterm
  (use-package vterm
    :defer t
    :preface
    (defvar vterms (make-hash-table :test 'equal))
    (defvar vterm-layout-active nil "Flag to indicate if vterm layout is active.")
    (defvar previous-window-configuration nil "Stores the previous window configuration.")
    (defvar vterm-right-buffer nil "Holds the current right-side vterm buffer.")

    (defun toggle-vterm (&optional n)
      (interactive)
      (let* ((project (projectile-project-name))
             (project-vterms (gethash project vterms))
             (default-directory (or (vc-root-dir) default-directory)))
        (setq project-vterms (seq-filter 'buffer-live-p project-vterms))
        (puthash project project-vterms vterms)
        (cond ((numberp n)
               (let ((buf (vterm (generate-new-buffer-name (format "*vterm-%s-%d*" project n)))))
                 (push buf project-vterms)
                 (puthash project project-vterms vterms)
                 (switch-to-buffer buf)))
              ((null project-vterms)
               (let ((buf (vterm (generate-new-buffer-name (format "*vterm-%s-1*" project)))))
                 (push buf project-vterms)
                 (puthash project project-vterms vterms)
                 (switch-to-buffer buf)))
              ((seq-contains-p project-vterms (current-buffer))
               (switch-to-buffer (car (seq-difference (buffer-list) project-vterms))))
              (t
               (switch-to-buffer (car (seq-intersection (buffer-list) project-vterms)))))))

    (defun vterm-layout ()
      "Toggle a layout with three vterm buffers: one to the left and two to the right."
      (interactive)
      (let* ((project (projectile-project-name))
             (project-vterms (gethash project vterms))
             (default-directory (or (vc-root-dir) default-directory)))
        (if vterm-layout-active
            (progn
              (set-window-configuration previous-window-configuration)
              (setq vterm-layout-active nil))
          (setq previous-window-configuration (current-window-configuration))
          (delete-other-windows)
          (let ((left-vterm (vterm (generate-new-buffer-name (format "*vterm-%s-1*" project)))))
            (push left-vterm project-vterms)
            (puthash project project-vterms vterms)
            (split-window-right)
            (other-window 1)
            (let ((top-right-vterm (vterm (generate-new-buffer-name (format "*vterm-%s-2*" project)))))
              (push top-right-vterm project-vterms)
              (puthash project project-vterms vterms)
              (split-window-below)
              (other-window 1)
              (let ((bottom-right-vterm (vterm (generate-new-buffer-name (format "*vterm-%s-3*" project)))))
                (push bottom-right-vterm project-vterms)
                (puthash project project-vterms vterms)
                (balance-windows)
                (select-window (get-buffer-window left-vterm))
                (setq vterm-layout-active t)))))))

    (defun toggle-vterm-right ()
      "Toggle a vterm buffer on the right side of the screen."
      (interactive)
      (let* ((project (projectile-project-name))
             (default-directory (or (vc-root-dir) default-directory))
             (project-vterms (gethash project vterms)))
        (if (and vterm-right-buffer (buffer-live-p vterm-right-buffer))
            (if (eq (current-buffer) vterm-right-buffer)
                (progn
                  (delete-window)
                  (bury-buffer vterm-right-buffer)
                  (balance-windows))
              (select-window (display-buffer vterm-right-buffer)))
          (split-window-right)
          (other-window 1)
          (setq vterm-right-buffer (vterm (generate-new-buffer-name (format "*vterm-%s-right*" project))))
          (push vterm-right-buffer project-vterms)
          (puthash project project-vterms vterms)
          (switch-to-buffer vterm-right-buffer))))

    (defun kill-all-vterms-in-project ()
      "Kill all vterm buffers associated with the current project."
      (interactive)
      (let* ((project (projectile-project-name))
             (project-vterms (gethash project vterms))
             (project-root (or (vc-root-dir) default-directory)))
        (setq project-vterms (seq-filter 'buffer-live-p project-vterms))
        (dolist (vterm-buffer project-vterms)
          (with-current-buffer vterm-buffer
            (when (string-prefix-p project-root default-directory)
              (kill-buffer vterm-buffer))))
        (puthash project (seq-filter 'buffer-live-p project-vterms) vterms)))

    :config
    ;; Don't query about killing vterm buffers, just kill it
    (defadvice vterm (after kill-with-no-query nil activate)
      (set-process-query-on-exit-flag (get-buffer-process ad-return-value) nil)))
#+end_src

* Version
Using magit with forge, creates the best environment for working with
Git inside Emacs, the only thing missing here is a way to approve PR.
For forge, create a file called ~/.authinfo with the following:

- machine api.github.com login gako358^forge password ==secret-token==

** blamer
#+begin_src emacs-lisp
  (use-package blamer
    :custom
    (blamer-idle-time 0.3)
    (blamer-min-offset 70))
#+end_src

** git-gutter
#+begin_src emacs-lisp
  (use-package git-gutter
    :hook (prog-mode . git-gutter-mode)
    :custom
    (git-gutter:update-interval 0.05))

  (use-package git-gutter-fringe
    :after git-gutter
    :config
    (fringe-mode '(8 . 8))
    (define-fringe-bitmap 'git-gutter-fr:added
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:modified
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:deleted
      [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
      nil nil 'center))
#+end_src
