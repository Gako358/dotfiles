#+STARTUP: overview
#+TITLE: MerrinX Config
#+CREATOR: Merrinx
#+LANGUAGE: en

* Installation
Git clone https://github.com/gako358/dotfiles.git.
The configuration is setup using NixOS, check README.


* Appearance
Using the dashboard package with the kaolin-theme to enhance the startup experience and overall look of Emacs.

** Dashboard
The dashboard package is configured to display a welcoming startup screen with a custom banner, recent files, bookmarks, projects, and agenda items.

#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (setq dashboard-startup-banner 'logo
          dashboard-banner-logo-title "Welcome back Master"
          dashboard-set-file-icons t
          dashboard-center-content t
          dashboard-items '((recents  . 5)
                            (bookmarks . 5)
                            (projects . 5)
                            (agenda . 5))
          initial-buffer-choice (lambda () (get-buffer-create "*dashboard*")))
    :init
    :hook (after-init . dashboard-setup-startup-hook))
#+end_src

** Fonts
Custom fonts are set using "Iosevka Nerd Font" for both the main text and the mode-line, ensuring a consistent and visually appealing interface across all frames.

#+begin_src emacs-lisp
  (add-hook 'after-make-frame-functions
	    (lambda (f)
	      (with-selected-frame f
		(set-frame-font "Iosevka Nerd Font 11" nil t)
		(set-face-attribute 'mode-line nil :font "Iosevka Nerd Font 12" :height 100))))

  (add-to-list 'default-frame-alist '(height . 64))
  (add-to-list 'default-frame-alist '(width . 370))
#+end_src

** Icons

All-the-icons: Provides a rich set of icons for various file types and modes.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+end_src

All-the-icons-ivy-rich: Enhances Ivy's minibuffer completion with icons, activated on startup.

#+begin_src emacs-lisp
  (use-package all-the-icons-ivy-rich
    :ensure t
    :init (all-the-icons-ivy-rich-mode 1))
#+end_src

Nerd-icons: Sets "Iosevka Nerd Font" as the icon font family.
Nerd-icons-completion: Integrates with Marginalia for enhanced completion visuals.
Nerd-icons-corfu: Adds pretty icons to Corfu completion menus.

#+begin_src emacs-lisp
  (use-package nerd-icons
    :ensure t
    :config
    (setq nerd-icons-font-family "Iosevka Nerd Font"))

  ;; Pretty icons for completion
  (use-package nerd-icons-completion
    :ensure t
    :after marginalia
    :config
    (nerd-icons-completion-marginalia-setup)
    (nerd-icons-completion-mode 1))

  (use-package nerd-icons-corfu
    :ensure t
    :after corfu
    :config
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))

#+end_src

** Modeline

This enables spaceline, it looks better and works very well with my theme of choice.

#+begin_src emacs-lisp
  (use-package spaceline
    :ensure t
    :init
    (setq spaceline-buffer-encoding-abbrev-p nil
  	  spaceline-line-column-p nil
  	  spaceline-line-p nil
  	  powerline-default-separator 'arrow
  	  powerline-gui-use-vcs-glyph t
  	  powerline-height 28
  	  spaceline-highlight-face-func 'spaceline-highlight-face-modified
  	  spaceline-workspace-numbers-unicode t
  	  spaceline-window-numbers-unicode t
  	  spaceline-separator-dir-left '(left . right)
  	  spaceline-separator-dir-right '(right . left)
  	  spaceline-flycheck-bullet "❀ %s")
    :config
    (require 'spaceline-config)
    (spaceline-spacemacs-theme)

    (spaceline-define-segment nasy:version-control
      "Version control information."
      (when vc-mode
        (let ((branch (mapconcat 'concat (cdr (split-string vc-mode "[:-]")) "-")))
          (powerline-raw
           (s-trim (concat "  "
                           branch
                           (when (buffer-file-name)
                             (pcase (vc-state (buffer-file-name))
                               (`up-to-date " ✓")
                               (`edited " ❓")
                               (`added " ➕")
                               (`unregistered " ■")
                               (`removed " ✘")
                               (`needs-merge " ↓")
                               (`needs-update " ↑")
                               (`ignored " ✦")
                               (_ " ⁇")))))))))

    (spaceline-define-segment nasy-time
      "Time"
      (format-time-string "%b %d, %Y - %H:%M ")
      :tight-right t)

    (spaceline-define-segment flycheck-status
      "An `all-the-icons' representation of `flycheck-status'"
      (let* ((text
              (pcase flycheck-last-status-change
                (`finished (if flycheck-current-errors
                               (let ((count (let-alist (flycheck-count-errors flycheck-current-errors)
                                              (+ (or .warning 0) (or .error 0)))))
                                 (format "✖ %s Issue%s" count (if (eq 1 count) "" "s")))
                             "✔ No Issues"))
                (`running     "⟲ Running")
                (`no-checker  "⚠")
                (`not-checked "✣ Disabled")
                (`errored     "⚠ Error")
                (`interrupted "⛔ Interrupted")
                (`suspicious  "")))
             (f (cond
                 ((string-match "⚠" text) `(:height 0.9 :foreground ,(face-attribute 'spaceline-flycheck-warning :foreground)
                                                    :background "#1d5464"))
                 ((string-match "✖ [0-9]" text) `(:height 0.9 :foreground ,(face-attribute 'spaceline-flycheck-error :foreground)
                                                          :background "#333333"))
                 ((string-match "✣ Disabled" text) `(:height 0.9))
                 (t '(:height 0.9 :inherit)))))
        (propertize (format " %s " text)
                    'face f
                    'help-echo "Show Flycheck Errors"
                    'mouse-face '(:box 1)
                    'local-map (make-mode-line-mouse-map 'mouse-1 (lambda () (interactive) (flycheck-list-errors)))))
      :when active))
#+end_src

** Themes
The kaolin-themes package is used with specific settings for a personalized look, loading the "kaolin-ocean" theme.

#+begin_src emacs-lisp
  (use-package bivrost-theme
    :ensure t
    :config
    (load-theme 'bivrost t))
#+end_src

* Completion
Using Corfu, vertico and cape for code completion.

#+begin_src emacs-lisp
  ;; Enable indentation and completion with the TAB key.
  (setq tab-always-indent 'complete)

  ;; Cycle with the TAB key if there are only few candidates.
  (setq completion-cycle-threshold 3)
#+end_src

** Cape
Completion At Point Extensions:
- Cape: Provides extensions for completion-at-point-functions to enhance the completion experience for files and Emacs Lisp blocks.

#+begin_src emacs-lisp
  ;; Completion At Point Extensions.
  (use-package cape
    :ensure t
    :init
    (add-hook 'completion-at-point-functions
  	      (cape-capf-accept-all #'cape-file))
    (add-hook 'completion-at-point-functions
  	      (cape-capf-accept-all #'cape-dabbrev))
    (add-hook 'completion-at-point-functions
  	      (cape-capf-accept-all #'cape-keyword))
    (add-hook 'completion-at-point-functions
  	      (cape-capf-accept-all #'cape-line))
    (add-hook 'completion-at-point-functions
  	      (cape-capf-accept-all #'cape-elisp-block)))
#+end_src

** Copilot
AI-Powered Code Completion:
- Copilot: Integrates GitHub Copilot for AI-powered code completion, with custom keybindings and configuration for different modes.

#+begin_src emacs-lisp
  (use-package dash :ensure t)
  (use-package s :ensure t)
  (use-package editorconfig
    :ensure t
    :config
    (editorconfig-mode 1))
  (use-package f :ensure t)
  (use-package copilot
    :ensure t
    :bind (:map copilot-completion-map
		("C-e" . copilot-accept-completion)
		("C-S-e" . copilot-accept-completion-by-word))
    :config
    (evil-leader/set-key
      "cp" 'copilot-mode)

    (add-to-list 'copilot-indentation-alist '(prog-mode . 2))
    (add-to-list 'copilot-indentation-alist '(org-mode . 2))
    (add-to-list 'copilot-indentation-alist '(text-mode . 2))
    (add-to-list 'copilot-indentation-alist '(closure-mode . 2))
    (add-to-list 'copilot-indentation-alist '(nix-ts-mode . 2))
    (add-to-list 'copilot-indentation-alist '(nix-mode . 2))
    (add-to-list 'copilot-indentation-alist '(scala-ts-mode . 2))
    (add-to-list 'copilot-indentation-alist '(scala-mode . 2))
    (add-to-list 'copilot-indentation-alist '(java-ts-mode . 2))
    (add-to-list 'copilot-indentation-alist '(java-mode . 2))
    (add-to-list 'copilot-indentation-alist '(emacs-lisp-mode . 2)))
#+end_src

** Copilot-Chat
#+begin_src emacs-lisp
  (use-package copilot-chat
    :config
    (evil-leader/set-key
      "ca" 'copilot-chat-add-current-buffer
      "cd" 'copilot-chat-del-current-buffer
      "ce" 'copilot-chat-explain
      "cf" 'copilot-chat-fix
      "cg" 'copilot-chat-insert-commit-message
      "ch" 'copilot-chat-hide
      "cl" 'copilot-chat-list
      "cL" 'copilot-chat-list-refresh
      "cm" 'copilot-chat-set-model
      "cr" 'copilot-chat-reset
      "cv" 'copilot-chat-review
      "cV" 'copilot-chat-review-whole-buffer
      "cc" 'copilot-chat-display))
#+end_src

** Corfu
Completion Overlay Region Function:
- Corfu: Provides a completion overlay for better in-line completion, with custom keybindings for navigation and configuration for an improved user experience.

#+begin_src emacs-lisp
  ;; Completion Overlay Region Function.
  (use-package corfu
    :init
    (global-corfu-mode 1)
    (setq global-corfu-minibuffer
  	    (lambda ()
  	      (not (or (bound-and-true-p mct--active)
  		       (bound-and-true-p vertico--input)
  		       (eq (current-local-map) read-passwd-map)))))
    :bind (:map corfu-map
  				  ("C-n" . corfu-next)
  				  ("C-p" . corfu-previous)
  				  ("C-h" . corfu-info-documentation)
  				  ("C-S-t" . my/corfu-quit-or-abort)
  				  )

    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-preview-current nil)
    (corfu-quit-at-boundary t)
    (corfu-quit-no-match t)

    :config
    ;; Add Evil-specific binding for C-y in Corfu
    (with-eval-after-load 'evil
      (define-key evil-insert-state-map (kbd "C-y")
                  (lambda ()
                    (interactive)
                    (if (and (boundp 'corfu-mode) corfu-mode)
                        (corfu-insert)
                      (evil-paste-before 1)))))

    (defun my/corfu-quit-or-abort ()
      "Abort Corfu if active, otherwise fall back to default behavior."
      (interactive)
      (if corfu--frame
          (corfu-quit)
        (keyboard-escape-quit)))
    )
#+end_src

** Embark
Context Menu for Actions:
- Embark: Offers a context menu for performing actions on selected items directly from the completion interface.

#+begin_src emacs-lisp
  (use-package embark
    ;; Embark is an Emacs package that acts like a context menu, allowing
    ;; users to perform context-sensitive actions on selected items
    ;; directly from the completion interface.
    :ensure t
    :defer t
    :commands (embark-act
  	     embark-dwim
  	     embark-export
  	     embark-collect
  	     embark-bindings
  	     embark-prefix-help-command)
    :init
    (setq prefix-help-command #'embark-prefix-help-command)

    :config
    ;; Hide the mode line of the Embark live/completions buffers
    (add-to-list 'display-buffer-alist
                 '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                   nil
                   (window-parameters (mode-line-format . none)))))

  (use-package embark-consult
    :ensure t
    :after (embark consult)
    :hook
    (embark-collect-mode . consult-preview-at-point-mode))


  (evil-leader/set-key
    "ea" 'embark-act
    "ew" 'embark-dwim)
#+end_src

** Eldoc
#+begin_src emacs-lisp
  (use-package eldoc-box
    :ensure t
    :config
    (evil-leader/set-key
      "lh" 'eldoc-box-help-at-point))
#+end_src

** Marginalia
Annotations for Completion Candidates:
- Marginalia: Adds rich annotations to completion candidates, enhancing the completion experience with additional context.

#+begin_src emacs-lisp
  ;; Annotations for completion candidates.
  (use-package marginalia
    ;; Marginalia allows Embark to offer you preconfigured actions in more contexts.
    ;; In addition to that, Marginalia also enhances Vertico by adding rich
    ;; annotations to the completion candidates displayed in Vertico's interface.
    :ensure t
    :defer t
    :commands (marginalia-mode marginalia-cycle)
    :hook (after-init . marginalia-mode))
#+end_src

** Orderless
Flexible Matching:
- Orderless: Provides flexible matching capabilities for completion, allowing multiple patterns to be matched in any order.

#+begin_src emacs-lisp
  ;; Space-separated matching components matching in any order.
  (use-package orderless
    ;; Vertico leverages Orderless' flexible matching capabilities, allowing users
    ;; to input multiple patterns separated by spaces, which Orderless then
    ;; matches in any order against the candidates.
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Vertico
Vertical Interactive Completion UI:
- Vertico: Offers a vertical completion interface, improving the user experience for navigating and selecting completion candidates.
- Vertico-Posframe: Provides a posframe handler for Vertico, ensuring the completion interface is displayed in a consistent and visually appealing manner.

#+begin_src emacs-lisp
  ;; Vertical interactive completion UI.
  ;; Tip: You can remove the `vertico-mode' use-package and replace it
  ;;      with the built-in `fido-vertical-mode'.
  (use-package vertico
    ;; (Note: It is recommended to also enable the savehist package.)
    :ensure t
    :defer t
    :commands vertico-mode
    :hook (after-init . vertico-mode))

  (use-package vertico-posframe
    :hook (vertico-mode . vertico-posframe-mode)
    :config
    (setq vertico-posframe-parameters
	'((left-fringe . 8)
	  (right-fringe . 8)))
    (setq vertico-posframe-poshandler #'posframe-poshandler-frame-bottom-right-corner))
#+end_src

** Grep
Writable Grep:
- wgrep: Allows editing of grep buffers, enabling changes to be applied directly to files.

#+begin_src emacs-lisp
  (use-package wgrep)
#+end_src

** Yasnippet
Snippet Expansion:
- Yasnippet: Provides support for snippet expansion, allowing predefined templates to be used for faster coding.
#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :init
    (yas-global-mode 1))
#+end_src

* Core
#+begin_src emacs-lisp
  (defvar minimal-emacs-ui-features '()
    "List of user interface features to disable in minimal Emacs setup.

    This variable holds a list Emacs UI features that can be enabled:
    - `context-menu`: Enables the context menu in graphical environments.
    - `tool-bar`: Enables the tool bar in graphical environments.
    - `menu-bar`: Enables the menu bar in graphical environments.
    - `dialogs`: Enables both file dialogs and dialog boxes.
    - `tooltips`: Enables tooltips.

    Each feature in the list corresponds to a specific UI component that can be
    turned on.")

  (defvar minimal-emacs-frame-title-format "%b – Emacs"
    "Template for displaying the title bar of visible and iconified frame.")

  (defvar minimal-emacs-debug nil
    "Non-nil to enable debug.")

  (defvar minimal-emacs-gc-cons-threshold (* 16 1024 1024)
    "The value of `gc-cons-threshold' after Emacs startup.")

  (defvar minimal-emacs-package-initialize-and-refresh t
    "Whether to automatically initialize and refresh packages.
    When set to non-nil, Emacs will automatically call `package-initialize' and
    `package-refresh-contents' to set up and update the package system.")

  (defvar minimal-emacs-user-directory user-emacs-directory
    "The default value of the `user-emacs-directory' variable.")

    ;;; Load pre-early-init.el

  (defun minimal-emacs-load-user-init (filename)
    "Execute a file of Lisp code named FILENAME."
    (let ((user-init-file
           (expand-file-name filename
                             minimal-emacs-user-directory)))
      (when (file-exists-p user-init-file)
        (load user-init-file nil t))))

  (minimal-emacs-load-user-init "pre-early-init.el")

  (setq custom-theme-directory
        (expand-file-name "themes/" minimal-emacs-user-directory))
  (setq custom-file (expand-file-name "custom.el" minimal-emacs-user-directory))

    ;;; Garbage collection
  ;; Garbage collection significantly affects startup times. This setting delays
  ;; garbage collection during startup but will be reset later.

  (setq gc-cons-threshold most-positive-fixnum)

  (add-hook 'emacs-startup-hook
            (lambda ()
              (setq gc-cons-threshold minimal-emacs-gc-cons-threshold)))

    ;;; Misc

  (set-language-environment "UTF-8")

  ;; Set-language-environment sets default-input-method, which is unwanted.
  (setq default-input-method nil)

    ;;; Performance

  ;; Prefer loading newer compiled files
  (setq load-prefer-newer t)

  ;; Font compacting can be very resource-intensive, especially when rendering
  ;; icon fonts on Windows. This will increase memory usage.
  (setq inhibit-compacting-font-caches t)

  (unless (daemonp)
    (let ((old-value (default-toplevel-value 'file-name-handler-alist)))
      (set-default-toplevel-value
       'file-name-handler-alist
       ;; Determine the state of bundled libraries using calc-loaddefs.el.
       ;; If compressed, retain the gzip handler in `file-name-handler-alist`.
       ;; If compiled or neither, omit the gzip handler during startup for
       ;; improved startup and package load time.
       (if (eval-when-compile
             (locate-file-internal "calc-loaddefs.el" load-path))
           nil
         (list (rassq 'jka-compr-handler old-value))))
      ;; Ensure the new value persists through any current let-binding.
      (set-default-toplevel-value 'file-name-handler-alist
                                  file-name-handler-alist)
      ;; Remember the old value to reset it as needed.
      (add-hook 'emacs-startup-hook
                (lambda ()
                  (set-default-toplevel-value
                   'file-name-handler-alist
                   ;; Merge instead of overwrite to preserve any changes made
                   ;; since startup.
                   (delete-dups (append file-name-handler-alist old-value))))
                101))

    (unless noninteractive
      (unless minimal-emacs-debug
        (unless minimal-emacs-debug
          ;; Suppress redisplay and redraw during startup to avoid delays and
          ;; prevent flashing an unstyled Emacs frame.
          ;; (setq-default inhibit-redisplay t) ; Can cause artifacts
          (setq-default inhibit-message t)

          ;; Reset the above variables to prevent Emacs from appearing frozen or
          ;; visually corrupted after startup or if a startup error occurs.
          (defun minimal-emacs--reset-inhibited-vars-h ()
            ;; (setq-default inhibit-redisplay nil) ; Can cause artifacts
            (setq-default inhibit-message nil)
            (remove-hook 'post-command-hook #'minimal-emacs--reset-inhibited-vars-h))

          (add-hook 'post-command-hook
                    #'minimal-emacs--reset-inhibited-vars-h -100))

        (dolist (buf (buffer-list))
          (with-current-buffer buf
            (setq mode-line-format nil)))

        (put 'mode-line-format 'initial-value
             (default-toplevel-value 'mode-line-format))
        (setq-default mode-line-format nil)

        (defun minimal-emacs--startup-load-user-init-file (fn &rest args)
          "Advice for startup--load-user-init-file to reset mode-line-format."
          (unwind-protect
              (progn
                ;; Start up as normal
                (apply fn args))
            ;; If we don't undo inhibit-{message, redisplay} and there's an
            ;; error, we'll see nothing but a blank Emacs frame.
            (setq-default inhibit-message nil)
            (unless (default-toplevel-value 'mode-line-format)
              (setq-default mode-line-format
                            (get 'mode-line-format 'initial-value)))))

        (advice-add 'startup--load-user-init-file :around
                    #'minimal-emacs--startup-load-user-init-file))

      ;; Without this, Emacs will try to resize itself to a specific column size
      (setq frame-inhibit-implied-resize t)

      ;; A second, case-insensitive pass over `auto-mode-alist' is time wasted.
      ;; No second pass of case-insensitive search over auto-mode-alist.
      (setq auto-mode-case-fold nil)

      ;; Reduce *Message* noise at startup. An empty scratch buffer (or the
      ;; dashboard) is more than enough, and faster to display.
      (setq inhibit-startup-screen t
            inhibit-startup-echo-area-message user-login-name)
      (setq initial-buffer-choice nil
            inhibit-startup-buffer-menu t
            inhibit-x-resources t)

      ;; Disable bidirectional text scanning for a modest performance boost.
      (setq-default bidi-display-reordering 'left-to-right
                    bidi-paragraph-direction 'left-to-right)

      ;; Give up some bidirectional functionality for slightly faster re-display.
      (setq bidi-inhibit-bpa t)

      ;; Remove "For information about GNU Emacs..." message at startup
      (advice-add #'display-startup-echo-area-message :override #'ignore)

      ;; Suppress the vanilla startup screen completely. We've disabled it with
      ;; `inhibit-startup-screen', but it would still initialize anyway.
      (advice-add #'display-startup-screen :override #'ignore)

      ;; Shave seconds off startup time by starting the scratch buffer in
      ;; `fundamental-mode'
      (setq initial-major-mode 'fundamental-mode
            initial-scratch-message nil)

      (unless minimal-emacs-debug
        ;; Unset command line options irrelevant to the current OS. These options
        ;; are still processed by `command-line-1` but have no effect.
        (unless (eq system-type 'darwin)
          (setq command-line-ns-option-alist nil))
        (unless (memq initial-window-system '(x pgtk))
          (setq command-line-x-option-alist nil)))))

    ;;; Native compilation and Byte compilation

  (if (and (featurep 'native-compile)
           (fboundp 'native-comp-available-p)
           (native-comp-available-p))
      ;; Activate `native-compile'
      (setq native-comp-jit-compilation t
            native-comp-deferred-compilation t  ; Obsolete since Emacs 29.1
            package-native-compile t)
    ;; Deactivate the `native-compile' feature if it is not available
    (setq features (delq 'native-compile features)))

  ;; Suppress compiler warnings and don't inundate users with their popups.
  (setq native-comp-async-report-warnings-errors
        (or minimal-emacs-debug 'silent))
  (setq native-comp-warning-on-missing-source minimal-emacs-debug)

  (setq debug-on-error minimal-emacs-debug
        jka-compr-verbose minimal-emacs-debug)

  (setq byte-compile-warnings minimal-emacs-debug)
  (setq byte-compile-verbose minimal-emacs-debug)

    ;;; UI elements

  (setq frame-title-format minimal-emacs-frame-title-format
        icon-title-format minimal-emacs-frame-title-format)

  ;; Disable startup screens and messages
  (setq inhibit-splash-screen t)

  ;; I intentionally avoid calling `menu-bar-mode', `tool-bar-mode', and
  ;; `scroll-bar-mode' because manipulating frame parameters can trigger or queue
  ;; a superfluous and potentially expensive frame redraw at startup, depending
  ;; on the window system. The variables must also be set to `nil' so users don't
  ;; have to call the functions twice to re-enable them.
  (unless (memq 'menu-bar minimal-emacs-ui-features)
    (push '(menu-bar-lines . 0) default-frame-alist)
    (unless (memq window-system '(mac ns))
      (setq menu-bar-mode nil)))

  (unless (daemonp)
    (unless noninteractive
      (when (fboundp 'tool-bar-setup)
        ;; Temporarily override the tool-bar-setup function to prevent it from
        ;; running during the initial stages of startup
        (advice-add #'tool-bar-setup :override #'ignore)
        (define-advice startup--load-user-init-file
            (:after (&rest _) minimal-emacs-setup-toolbar)
          (advice-remove #'tool-bar-setup #'ignore)
          (when tool-bar-mode
            (tool-bar-setup))))))
  (unless (memq 'tool-bar minimal-emacs-ui-features)
    (push '(tool-bar-lines . 0) default-frame-alist)
    (setq tool-bar-mode nil))

  (push '(vertical-scroll-bars) default-frame-alist)
  (push '(horizontal-scroll-bars) default-frame-alist)
  (setq scroll-bar-mode nil)
  (when (fboundp 'horizontal-scroll-bar-mode)
    (horizontal-scroll-bar-mode -1))

  (unless (memq 'tooltips minimal-emacs-ui-features)
    (when (bound-and-true-p tooltip-mode)
      (tooltip-mode -1)))

  ;; Disable GUIs because they are inconsistent across systems, desktop
  ;; environments, and themes, and they don't match the look of Emacs.
  (unless (memq 'dialogs minimal-emacs-ui-features)
    (setq use-file-dialog nil)
    (setq use-dialog-box nil))

    ;;; LSP
  (setenv "LSP_USE_PLISTS" "true")

  ;; Disable sound bell
  (setq visible-bell       nil
        ring-bell-function #'ignore)


  ;; Ensure Emacs loads the most recent byte-compiled files.
  (setq load-prefer-newer t)

  ;; Ensure JIT compilation is enabled for improved performance by
  ;; native-compiling loaded .elc files asynchronously
  (setq native-comp-jit-compilation t)
                                          ;(setq native-comp-deferred-compilation t) ; Deprecated in Emacs > 29.1

                                          ;(use-package compile-angel
                                          ;  :ensure t
                                          ;  :demand t
                                          ;  :config
                                          ;  (compile-angel-on-load-mode)
                                          ;  (add-hook 'emacs-lisp-mode-hook #'compile-angel-on-save-local-mode))

  ;; Auto-revert in Emacs is a feature that automatically updates the
  ;; contents of a buffer to reflect changes made to the underlying file
  ;; on disk.
  (add-hook 'after-init-hook #'global-auto-revert-mode)

  ;; recentf is an Emacs package that maintains a list of recently
  ;; accessed files, making it easier to reopen files you have worked on
  ;; recently.
  (add-hook 'after-init-hook #'recentf-mode)

  ;; savehist is an Emacs feature that preserves the minibuffer history between
  ;; sessions. It saves the history of inputs in the minibuffer, such as commands,
  ;; search strings, and other prompts, to a file. This allows users to retain
  ;; their minibuffer history across Emacs restarts.
  (add-hook 'after-init-hook #'savehist-mode)

  ;; save-place-mode enables Emacs to remember the last location within a file
  ;; upon reopening. This feature is particularly beneficial for resuming work at
  ;; the precise point where you previously left off.
  (add-hook 'after-init-hook #'save-place-mode)

  ;; Turn on which-key-mode
  (add-hook 'after-init-hook 'which-key-mode)

  ;; Turn off autosave-mode
  ;; turn off backup-files
  (auto-save-mode -1)
  (setq make-backup-files nil)
  (setq auto-save-default nil)

  ;;; Line numbers
  (setq display-line-numbers-type 'relative)
  (global-display-line-numbers-mode)
#+end_src

* Edit
Edit, format, and grammar support for various programming languages and markdown.

** Apheleia
Formatters:
- Apheleia: Provides on-the-fly code formatting using various formatters:
  -  Scalafmt for Scala
  -  Black for Python
  -  Prettier for TypeScript and JavaScript
  -  Google Java Format for Java
  -  nixpkgs-fmt for Nix

#+begin_src emacs-lisp
  ;; Formatters
  (use-package apheleia
    :config
    ;; Add scalafmt for Scala
    (push '(scalafmt . ("scalafmt" "--stdin" "--non-interactive" "--quiet" "--stdout")) apheleia-formatters)
    (push '(scala-ts-mode . scalafmt) apheleia-mode-alist)

    ;; Add black for Python
    (push '(black . ("black" "-")) apheleia-formatters)
    (push '(python-mode . black) apheleia-mode-alist)

    ;; Add prettier for TypeScript and JavaScript
    (push '(prettier . ("prettier" "--stdin-filepath" buffer-file-name)) apheleia-formatters)
    (push '(typescript-ts-mode . prettier) apheleia-mode-alist)
    (push '(js-ts-mode . prettier) apheleia-mode-alist)

    ;; Add google-java-format for Java
    (push '(google-java-format . ("google-java-format" "-")) apheleia-formatters)
    (push '(java-ts-mode . google-java-format) apheleia-mode-alist)

    ;; Add nixpkgs-fmt for Nix
    (push '(nixpkgs-fmt . ("nixpkgs-fmt")) apheleia-formatters)
    (push '(nix-mode . nixpkgs-fmt) apheleia-mode-alist))

  (apheleia-global-mode +1)
#+end_src

* Filetree
Config dirvish

#+begin_src emacs-lisp
  (use-package dirvish
    :ensure t
    :init
    (dirvish-override-dired-mode)
    :custom
    (dirvish-quick-access-entries ; It's a custom option, `setq' won't work
     '(("h" "~/"                          "Home")
       ("d" "~/Downloads/"                "Downloads")
       ("m" "/mnt/"                       "Drives")
       ("p" "~/src/"                      "Projects")
       ("t" "~/.local/share/Trash/files/" "TrashCan")))

    :config
    (setq dirvish-mode-line-format
          '(:left (sort symlink) :right (omit yank index)))
    (setq dirvish-attributes           ; The order *MATTERS* for some attributes
          '(vc-state subtree-state nerd-icons collapse git-msg file-time file-size)
          dirvish-side-attributes
          '(vc-state nerd-icons collapse file-size))
    (setq delete-by-moving-to-trash t)
    (setq dired-listing-switches
          "-l --almost-all --human-readable --group-directories-first --no-group")
    :bind ; Bind `dirvish-fd|dirvish-side|dirvish-dwim' as you see fit
    (
     :map dirvish-mode-map          ; Dirvish inherits `dired-mode-map'
     ("M-a"   . dirvish-quick-access)
     ("M-f"   . dirvish-file-info-menu)
     ("M-y"   . dirvish-yank-menu)
     ("M-h" . dired-up-directory)
     ("M-n" . dired-create-empty-file)
     ("M-v"   . dirvish-vc-menu)      ; remapped `dired-view-file'
     ("M-o" . dirvish-subtree-toggle)
     ("M-l" . dirvish-ls-switches-menu)
     ("M-m" . dirvish-mark-menu)
     ("M-t" . dirvish-layout-toggle)
     ("M-s" . dirvish-setup-menu)
     ("M-e" . dirvish-emerge-menu)
     ("M-q" . dirvish-quit)
     ("M-j" . dirvish-fd-jump)))

  (add-hook 'dired-mode-hook 'auto-revert-mode)
  (add-hook 'dirvish-setup-hook (lambda ()
                                  (visual-line-mode -1)
                                  (setq-local truncate-lines t)))

  (evil-leader/set-key
    "rf" 'dirvish)
#+end_src

* General
** direnv
#+begin_src emacs-lisp
  ;;; Direnv integration
  (use-package envrc
    :hook (after-init . envrc-global-mode))
#+end_src

* Grammars
Setting up treesitter grammars
#+begin_src emacs-lisp
  (use-package treesit
    :ensure nil
    :custom
    (treesit-font-lock-level 4) ;; Set font lock level for Tree-sitter
    :config
    (seq-do (lambda (it)
  	      (push it major-mode-remap-alist))
  	    '((css-mode . css-ts-mode) ;; Remap CSS mode to Tree-sitter mode
  	      (c-mode . c-ts-mode) ;; Remap C mode to Tree-sitter mode
  	      (dockerfile-mode . dockerfile-ts-mode) ;; Remap Dockerfile mode to Tree-sitter mode
  	      (haskell-mode . haskell-ts-mode) ;; Remap Haskell mode to Tree-sitter mode
  	      (java-mode . java-ts-mode) ;; Remap Java mode to Tree-sitter mode
  	      (javascript-mode . js-ts-mode) ;; Remap JavaScript mode to Tree-sitter mode
  	      (python-mode . python-ts-mode) ;; Remap Python mode to Tree-sitter mode
  	      (scala-mode . scala-ts-mode) ;; Remap Scala mode to Tree-sitter mode
  	      (sh-mode . bash-ts-mode) ;; Remap Shell Script mode to Tree-sitter mode
  	      (shell-script-mode . bash-ts-mode) ;; Remap Shell Script mode to Tree-sitter mode
  	      (typescript-mode . typescript-ts-mode) ;; Remap TypeScript mode to Tree-sitter mode
  	      (yaml-mode . yaml-ts-mode)))) ;; Remap YAML mode to Tree-sitter mode
#+end_src

* Keybindings
** Evil Mode
#+begin_src emacs-lisp
  ;; evil-want-keybinding must be declared before Evil and Evil Collection
  (setq evil-want-keybinding nil)

  (use-package evil
    :ensure t
    :init
    (setq evil-undo-system 'undo-fu)
    (setq evil-want-integration t)
    :custom
    (evil-want-Y-yank-to-eol t)
    :config
    (evil-select-search-module 'evil-search-module 'evil-search)
    (evil-mode 1))

  ;; Define scroll up
  (define-key evil-normal-state-map (kbd "C-u") 'evil-scroll-up)
  (define-key evil-visual-state-map (kbd "C-u") 'evil-scroll-up)
  (define-key evil-insert-state-map (kbd "C-u")
      	    (lambda ()
      	      (interactive)
      	      (evil-delete (point-at-bol) (point))))

  ;; Evil numbers inc and dec
  (define-key evil-normal-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-visual-state-map (kbd "C-a") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "C-x") 'evil-numbers/dec-at-pt)
  (define-key evil-visual-state-map (kbd "C-x") 'evil-numbers/dec-at-pt)
  ;; Redefine keys for switching windows
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
#+end_src

** Evil Collection
#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :ensure t
    :hook (evil-mode . evil-collection-init)
    :bind (([remap evil-show-marks] . evil-collection-consult-mark)
  	   ([remap evil-show-jumps] . evil-collection-consult-jump-list))
    :config
    ;; Make `evil-collection-consult-mark' and `evil-collection-consult-jump-list'
    ;; immediately available.
    (evil-collection-require 'consult)
    :custom
    (evil-collection-setup-debugger-keys nil)
    (evil-collection-calendar-want-org-bindings t)
    (evil-collection-unimpaired-want-repeat-mode-integration t))
#+end_src

** Evil Comment
#+begin_src emacs-lisp
  (with-eval-after-load "evil"
    (evil-define-operator my-evil-comment-or-uncomment (beg end)
      "Toggle comment for the region between BEG and END."
      (interactive "<r>")
      (comment-or-uncomment-region beg end))
    (evil-define-key 'normal 'global (kbd "gc") 'my-evil-comment-or-uncomment))
#+end_src

** Evil Leader
#+begin_src emacs-lisp
  (use-package evil-leader
    :ensure t
    :config
    (global-evil-leader-mode)
    (evil-leader/set-leader "<SPC>"))
#+end_src

** Evil Surround
#+begin_src emacs-lisp
  (use-package evil-surround
    :after evil
    :ensure t
    :defer t
    :commands global-evil-surround-mode
    :custom
    (evil-surround-pairs-alist
     '((?\( . ("(" . ")"))
       (?\[ . ("[" . "]"))
       (?\{ . ("{" . "}"))

       (?\) . ("(" . ")"))
       (?\] . ("[" . "]"))
       (?\} . ("{" . "}"))

       (?< . ("<" . ">"))
       (?> . ("<" . ">"))))
    :hook (after-init . global-evil-surround-mode))
#+end_src

** Evil Visual Star
#+begin_src emacs-lisp
  (use-package evil-visualstar
    :after evil
    :ensure t
    :defer t
    :commands global-evil-visualstar-mode
    :hook (after-init . global-evil-visualstar-mode))
#+end_src

* Languages
Using Eglot, Emacs built-in LSP client.
Setup using:
- C
- Dockerfile
- Haskell
- Java
- Kotlin
- Markdown
- Nix
- Rust
- SBT and Scala
- SQL
- Typescript
- Yaml

Using own created web mode, for Vue, TypeScript, and Tailwind.

** C
#+begin_src emacs-lisp
  ;; C language server
  (use-package c-ts-mode
    :hook (c-ts-mode . eglot-ensure)
    :mode (("\\.c\\'" . c-ts-mode)
	   ("\\.h\\'" . c-ts-mode)))
    #+end_src

** Dockerfile

#+begin_src emacs-lisp
  (use-package dockerfile-ts-mode)
#+end_src

** Haskell
#+begin_src emacs-lisp
  (use-package haskell-ts-mode
    :mode (("\\.hs\\'" . haskell-ts-mode)
	   ("\\.cabal\\'" . haskell-ts-mode)))
#+end_src

** Java
#+begin_src emacs-lisp
  ;; Java language server
  (use-package eglot-java
    :init
    :hook (java-ts-mode . eglot-java-mode))

  (with-eval-after-load 'eglot-java
    (evil-leader/set-key
      "ljn" 'eglot-java-file-new
      "ljx" 'eglot-java-run-main
      "ljt" 'eglot-java-run-test
      "ljN" 'eglot-java-project-new
      "ljT" 'eglot-java-project-build-task
      "ljR" 'eglot-java-project-build-refresh))

#+end_src

** Kotlin
#+begin_src emacs-lisp
  (use-package kotlin-ts-mode
    :init
    :hook (kotlin-ts-mode . eglot-ensure)
    :mode "\\.kt\\'")

  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
  	       '(kotlin-ts-mode .("kotlin-language-server"))))
#+end_src

** Markdown
Markdown Edit:
- Markdown Mode: Provides support for editing markdown files, enhancing the writing and formatting experience.

#+begin_src emacs-lisp
  ;; Markdown edit
  (use-package markdown-mode)
#+end_src

** Nix
#+begin_src emacs-lisp
  (use-package nix-ts-mode
    :mode "\\.nix\\'"
    :hook ((nix-ts-mode . eglot-ensure)
  	 (before-save . eglot-format-buffer)
  	 (before-save . nixpkgs-fmt-before-save)))

  (defun nixpkgs-fmt-before-save ()
    "Format the current buffer with nixpkgs-fmt if it is available."
    (when (eq major-mode 'nix-ts-mode)
      (if (executable-find "nixpkgs-fmt")
	  (let ((output-buffer (get-buffer-create "*nixpkgs-fmt*")))
	    (shell-command-on-region (point-min) (point-max) "nixpkgs-fmt" output-buffer t)
	    (kill-buffer output-buffer))
	(message "nixpkgs-fmt not found in PATH, skipping formatting."))))

  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(nix-ts-mode . ("nil" "--stdio"))))
#+end_src

** Rust
#+begin_src emacs-lisp
  ;; Rust language server
  (use-package rust-ts-mode
    :mode "\\.rs\\'"
    :hook
    (rust-ts-mode-hook . eglot-ensure)
    :init
    (with-eval-after-load 'org
      (cl-pushnew '("rust" . rust-ts-mode) org-src-lang-modes :test #'equal)))
#+end_src

** Scala
#+begin_src emacs-lisp
  ;; Scala language server
  (use-package scala-ts-mode
    :init
    (setq scala-ts-indent-offset 2)
    :hook ((scala-ts-mode . eglot-ensure)
	   (before-save . eglot-format-buffer)))

  (with-eval-after-load 'eglot
    (add-to-list 'eglot-server-programs
                 '(scala-ts-mode . ("metals"))))
#+end_src

** SQL
#+begin_src emacs-lisp
  ;; SQL syntax-based indentation
  (use-package sql-indent
    :ensure t
    :hook (sql-mode . sqlind-minor-mode))

  (with-eval-after-load 'sql-indent
    (add-hook 'sql-mode-hook 'sqlind-minor-mode))
#+end_src

** TypeScript
#+begin_src emacs-lisp
  (defun setup-tide-mode ()
    (interactive)
    (tide-setup)
    (flymake-mode +1)
    (eldoc-mode +1)
    (tide-hl-identifier-mode +1))

  ;; formats the buffer before saving
  (add-hook 'before-save-hook 'tide-format-before-save)
  (add-hook 'typescript-ts-mode-hook #'setup-tide-mode)

  ;; for js-ts-mode with eglot
  (use-package js-ts-mode
    :after eglot
    :hook (js-ts-mode . eglot-ensure)
    :mode
    (("\\.js\\'" . js-ts-mode)
     ("\\.ts\\'" . js-ts-mode)))
#+end_src

** Vue
#+begin_src emacs-lisp
  ;; Vue language support
  (use-package vue-ts-mode
    :after eglot
    :hook (vue-ts-mode . eglot-ensure)
    :mode
    (("\\.vue\\'" . vue-ts-mode)))
#+end_src

** Web Mode
#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :mode
    (("\\.phtml\\'" . web-mode)
     ("\\.php\\'" . web-mode)
     ("\\.tpl\\'" . web-mode)
     ("\\.[agj]sp\\'" . web-mode)
     ("\\.as[cp]x\\'" . web-mode)
     ("\\.erb\\'" . web-mode)
     ("\\.mustache\\'" . web-mode)
     ("\\.djhtml\\'" . web-mode)))
#+end_src

** Yaml
#+begin_src emacs-lisp
  ;; Ensure yaml-ts-mode is always enabled for YAML files
  (use-package yaml-ts-mode
    :ensure t
    :mode ("\\.yml\\'" . yaml-ts-mode)
    ("\\.yaml\\'" . yaml-ts-mode))

  ;; Use-package configuration for yaml-pro with tree-sitter support
  (use-package yaml-pro
    :ensure t
    :after treesit
    :hook ((yaml-ts-mode . yaml-pro-ts-mode)
    	 (yaml-mode . yaml-ts-mode)
    	 (before-save . yaml-pro-format-buffer))
    :config
    ;; Add keybindings for tree-sitter mode
    (define-key yaml-pro-ts-mode-map (kbd "M-RET") #'yaml-pro-ts-meta-return)
    (define-key yaml-pro-ts-mode-map (kbd "M-?") #'yaml-pro-ts-convolute-tree)
    (define-key yaml-pro-ts-mode-map (kbd "C-c @") #'yaml-pro-ts-mark-subtree)
    (define-key yaml-pro-ts-mode-map (kbd "C-c C-x C-y") #'yaml-pro-ts-paste-subtree)
    ;; Pretty formatter keybinding
    (define-key yaml-pro-ts-mode-map (kbd "C-c C-f") #'yaml-pro-format)
    ;; Easy movement with repeat map
    (keymap-set yaml-pro-ts-mode-map "C-M-n" #'yaml-pro-ts-next-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-p" #'yaml-pro-ts-prev-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-u" #'yaml-pro-ts-up-level)
    (keymap-set yaml-pro-ts-mode-map "C-M-d" #'yaml-pro-ts-down-level)
    (keymap-set yaml-pro-ts-mode-map "C-M-k" #'yaml-pro-ts-kill-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-<backspace>" #'yaml-pro-ts-kill-subtree)
    (keymap-set yaml-pro-ts-mode-map "C-M-a" #'yaml-pro-ts-first-sibling)
    (keymap-set yaml-pro-ts-mode-map "C-M-e" #'yaml-pro-ts-last-sibling)
    (defvar-keymap my/yaml-pro/tree-repeat-map
      :repeat t
      "n" #'yaml-pro-ts-next-subtree
      "p" #'yaml-pro-ts-prev-subtree
      "u" #'yaml-pro-ts-up-level
      "d" #'yaml-pro-ts-down-level
      "m" #'yaml-pro-ts-mark-subtree
      "k" #'yaml-pro-ts-kill-subtree
      "a" #'yaml-pro-ts-first-sibling
      "e" #'yaml-pro-ts-last-sibling
      "SPC" #'my/yaml-pro/set-mark)
    (defun my/yaml-pro/set-mark ()
      (interactive)
      (my/region/set-mark 'my/yaml-pro/set-mark))
    (defun my/region/set-mark (command-name)
      (if (eq last-command command-name)
    	(if (region-active-p)
    	    (progn
    	      (deactivate-mark)
    	      (message "Mark deactivated"))
    	  (activate-mark)
    	  (message "Mark activated"))
        (set-mark-command nil))))

  ;; Add hook to format YAML buffer before save
  (defun yaml-pro-format-buffer ()
    "Format the current buffer with yaml-pro-format."
    (when (derived-mode-p 'yaml-ts-mode)
      (yaml-pro-format)))

  #+end_src

* LSP
Setting up eglot LSP

** eglot
#+begin_src emacs-lisp
  (use-package eglot
    :ensure t
    :config
    (evil-leader/set-key
      "lo" 'eglot
      "la" 'eglot-code-actions
      "lf" 'apheleia-format-buffer
      "lr" 'eglot-rename
      "lH" 'eglot-inlay-hints-mode
      "ld" 'eglot-find-declaration
      "li" 'eglot-find-implementation
      "lt" 'eglot-find-typeDefinition
      "lI" 'eglot-organize-imports
      "ln" 'flymake-goto-next-error
      "lwd" 'flymake-show-project-diagnostics
      "lbd" 'flymake-show-buffer-diagnostics))
#+end_src
** eglot-booster
#+begin_src emacs-lisp
  (use-package eglot-booster
    :after eglot
    :config
    (eglot-booster-mode))
#+end_src

* Navigation
Setting up Consult for better navigation in Emacs
Vundo for undo-tree visualization

** Consult
#+begin_src emacs-lisp
  ;; Consulting completing-read
  (use-package consult
    :config

    (evil-leader/set-key
      "ff" 'consult-find
      "fg" 'consult-ripgrep)
    (setq consult-preview-key (list :debounce 0.1 'any)))

  (use-package consult-projectile
    :config

    (evil-leader/set-key
      "pf" 'consult-projectile-find-file
      "pw" 'consult-projectile-find-file-other-window
      "pp" 'consult-projectile-switch-project
      "TAB" 'consult-projectile-switch-to-buffer))

  (defun my/projectile-switch-to-buffer-with-eat ()
    "Switch to a buffer whose name includes 'eat' using consult-projectile."
    (interactive)
    (let ((filtered-buffers (seq-filter (lambda (buf)
        					(string-match-p "eat" (buffer-name buf)))
        				      (projectile-project-buffers))))
      (if filtered-buffers
        	(consult--read (mapcar #'buffer-name filtered-buffers)
        		       :prompt "Switch to terminal: "
        		       :require-match t
        		       :sort nil
        		       :category 'buffer
        		       :history 'buffer-name-history
        		       :state (consult--buffer-state))
        (message "No buffers found with term: %s" "eat"))))

  (defun my/consult-projectile-grep-at-point ()
    "Use consult to grep for the word at point within the projectile files. If a region is selected, use the selected text instead."
    (interactive)
    (let ((search-term (if (use-region-p)
          		 (buffer-substring-no-properties (region-beginning) (region-end))
          	       (let* ((word (thing-at-point 'word t))
          		      (bounds (bounds-of-thing-at-point 'symbol))
          		      (symbol (buffer-substring-no-properties (car bounds) (cdr bounds))))
          		 (if (or (string-match-p "-" word) (string-match-p "_" word))
          		     symbol
          		   word)))))
      (consult-ripgrep (projectile-project-root) search-term)))


  (defun my/consult-replace-word-with-preview ()
    "Replace occurrences of word under cursor using consult for visualization."
    (interactive)
    (let* ((bounds (if (evil-visual-state-p)
    		     (cons (region-beginning) (region-end))
    		   (bounds-of-thing-at-point 'word)))
    	 (word (when bounds
    		 (buffer-substring-no-properties (car bounds) (cdr bounds)))))
      (when word
        (if (evil-visual-state-p)
    	  (evil-normal-state))
        ;; First show the occurrences with consult-ripgrep
        (consult-ripgrep nil (regexp-quote word))
        ;; After viewing, prompt for replacement
        (let ((new-word (read-string (format "Replace \"%s\" with: " word))))
    	(when new-word
    	  (evil-ex (format "%%s/%s/%s/gc"
    			   (regexp-quote word)
    			   new-word)))))))


  (defun my/consult-replace-word-in-buffer ()
    "Replace word under cursor with preview using consult-line."
    (interactive)
    (let* ((bounds (if (evil-visual-state-p)
  		       (cons (region-beginning) (region-end))
  		     (bounds-of-thing-at-point 'word)))
  	   (word (when bounds
  		   (buffer-substring-no-properties (car bounds) (cdr bounds)))))
      (when word
  	(if (evil-visual-state-p)
  	    (evil-normal-state))
  	;; Show occurrences with consult-line
  	(consult-line (regexp-quote word))
  	;; After viewing, prompt for replacement
  	(let ((new-word (read-string (format "Replace \"%s\" with: " word))))
  	  (when new-word
  	    (evil-ex (format "%%s/%s/%s/gc"
  			     (regexp-quote word)
  			     new-word)))))))

  (evil-leader/set-key
    "SPC" 'my/consult-projectile-grep-at-point
    "DEL" 'kill-buffer
    "tr" 'rename-buffer
    "tl" 'my/projectile-switch-to-buffer-with-eat
    "sb" 'my/consult-replace-word-with-preview
    "sr" 'my/consult-replace-word-in-buffer)
#+end_src

** Vundo
#+begin_src emacs-lisp
  (use-package vundo
    :demand
    :custom
    (vundo-glyph-alist vundo-unicode-symbols))
#+end_src

* ORG
** Dslide

Programmable Org Presentation
#+begin_src emacs-lisp
   (use-package dslide
     :defer t
     :config
     ;; Add any additional configuration for dslide here
     )

   (with-eval-after-load 'dslide
     (define-key org-mode-map (kbd "C-c d s") 'dslide-start)
     (define-key org-mode-map (kbd "C-c d n") 'dslide-next)
     (define-key org-mode-map (kbd "C-c d p") 'dslide-prev))

   ;; Function to enable dslide-mode manually
   (defun enable-dslide-mode ()
     "Enable dslide-mode manually."
     (interactive)
     (dslide-mode 1))

   ;; Bind a key to enable dslide-mode manually
   (define-key org-mode-map (kbd "C-c d e") 'enable-dslide-mode)
#+end_src

** Org-Roam
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (file-truename "~/Documents/notes/src"))
    (org-roam-completion-everywhere t)
    (org-roam-capture-templates
     '(("d" "default" plain
	"%?"
	:if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
	:unnarrowed t)))
    :bind (("C-c n l" . org-roam-buffer-toggle)
	 ("C-c n f" . org-roam-node-find)
	 ("C-c n i" . org-roam-node-insert)
	 :map org-mode-map
	 ("C-M-i" . completion-at-point))
    :config
    (org-roam-setup)
    (org-roam-db-autosync-mode))

  (use-package org-modern
    :ensure t
    :hook ((org-mode . org-modern-mode)
           (org-agenda-finalize . org-modern-agenda)))

  ;; Define a prefix command for org-mode related commands
  (define-prefix-command 'org-prefix-map)

  ;; Bind the prefix command to "C-x o"
  (global-set-key (kbd "C-x o") 'org-prefix-map)

  ;; Bind org-roam-capture to "C-x o c"
  (define-key org-prefix-map (kbd "c") 'org-roam-capture)
#+end_src

* Projects
Projectile is the go-to project package to use with Emacs.
- Easy to use and setup, easy use of buffers.

#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :init
    (projectile-mode +1)
    :config
    (setq projectile-enable-caching t
	    projectile-completion-system 'ivy
	    projectile-indexing-method 'alien
	    projectile-sort-order 'recently-active
	    projectile-project-search-path '("~/Projects/" ("~/Projects/workspace/" . 1)))

    (evil-leader/set-key
      "pc" 'projectile-cleanup-known-projects))
#+end_src

* Terminal
** Detached
Setup emacs-detached

#+begin_src emacs-lisp
  (use-package detached
    :init
    (detached-init)
    :bind (([remap async-shell-command] . detached-shell-command)
  	   ([remap compile] . detached-compile)
  	   ([remap recompile] . detached-compile-recompile)
  	   ([remap detached-open-session] . detached-consult-session))
    :custom ((detached-show-output-on-attach t)
  	     (detached-terminal-data-command system-type)
  	     (detached-shell-program "bash")))

  (evil-leader/set-key
    "da" 'detached-attach-session
    "dd" 'detached-detach-session
    "dk" 'detached-kill-session
    "dl" 'detached-consult-commands
    "do" 'detached-open-session
    "dr" 'detached-delete-session
    "dR" 'detached-delete-sessions
    "ds" 'detached-shell-command
    "dv" 'detached-view-session
    "dc" 'detached-copy-session-command)

  ;; Define a custom variable to store commands
  (defvar detached-custom-commands nil
    "List of custom commands with their directories.
    Each element is a list (name dir command) where:
      - name is the display name for the command
      - dir is the directory where the command should be run
      - command is the shell command to execute")

  ;; Function to add a new command
  (defun detached-add-command (name dir command)
    "Add a new command to the list of custom commands."
    (interactive "sName: \nDDirectory: \nsCommand: ")
    (add-to-list 'detached-custom-commands (list name dir command))
    (message "Command '%s' added" name))

  ;; Function to remove a command
  (defun detached-remove-command (name)
    "Remove a command from the list of custom commands."
    (interactive
     (list
      (completing-read "Remove command: "
                       (mapcar #'car detached-custom-commands))))
    (setq detached-custom-commands
          (cl-remove-if (lambda (cmd) (string= (car cmd) name))
                        detached-custom-commands))
    (message "Command '%s' removed" name))

  ;; Function to run a command with detached
  (defun detached-run-custom-command (cmd)
    "Run a custom command using detached-shell-command."
    (let* ((dir (nth 1 cmd))
           (command (nth 2 cmd))
           (default-directory dir))
      (detached-shell-command command (concat "*detached: " (car cmd) "*"))))

  ;; Consult integration for command selection and execution
  (defun detached-consult-commands ()
    "Select and run a custom command using consult."
    (interactive)
    (if (null detached-custom-commands)
        (message "No custom commands defined. Use M-x detached-add-command to add one.")
      (let* ((candidates (mapcar (lambda (cmd)
                                   (cons (format "%-20s %s (in %s)"
                                                 (car cmd) (nth 2 cmd) (nth 1 cmd))
                                         cmd))
                                 detached-custom-commands))
             (selected (cdr (assoc (completing-read "Run command: " candidates nil t) candidates))))
        (when selected
          (detached-run-custom-command selected)))))

  ;; Custom commands to run different applications

  ;; Roskva bleep run server
  (detached-add-command "Bleep Server"
  		      "/home/merrinx/Projects/workspace/roskva/"
  		      "bleep run server")

  ;; Roskva bleep link app
  (detached-add-command "Bleep Link"
  		      "/home/merrinx/Projects/workspace/roskva/"
  		      "bleep link app -w --release")

  ;; Roskva npm
  (detached-add-command "Bleep App"
  		      "/home/merrinx/Projects/workspace/roskva/app/"
  		      "npm run dev")

#+end_src

** Eat
Setup emacs-eat
- Emulate a Terminal

#+begin_src emacs-lisp
  (use-package eat
    :hook (eshell-load . eat-eshell-mode)
    :commands eat-compile-terminfo
    :custom
    (eat-enable-auto-line-mode t)
    (eat-kill-buffer-on-exit t))

  (evil-leader/set-key
    "tt" 'eat-project
    "to" 'eat-project-other-window
    "tk" 'eat-kill-process)
#+end_src

* Version
Using magit with forge, creates the best environment for working with
Git inside Emacs, the only thing missing here is a way to approve PR.
For forge, create a file called ~/.authinfo with the following:

- machine api.github.com login gako358^forge password ==secret-token==

** Blamer
#+begin_src emacs-lisp
  (use-package blamer
    :custom
    (blamer-idle-time 0.3)
    (blamer-min-offset 70)

    :config
    (evil-leader/set-key
      "bm" 'blamer-mode))
#+end_src

** Git-gutter
#+begin_src emacs-lisp
  (use-package git-gutter
    :hook (prog-mode . git-gutter-mode)
    :custom
    (git-gutter:update-interval 0.05))

  (use-package git-gutter-fringe
    :after git-gutter
    :config
    (fringe-mode '(8 . 8))
    (define-fringe-bitmap 'git-gutter-fr:added
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:modified
      [224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224 224]
      nil nil 'center)
    (define-fringe-bitmap 'git-gutter-fr:deleted
      [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
      nil nil 'center))
#+end_src

** Magit
#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :config
    (evil-leader/set-key
      "/" 'magit-status))
#+end_src
